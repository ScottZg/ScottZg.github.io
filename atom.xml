<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张贵</title>
  <subtitle>为什么要这样做？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-30T10:09:30.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张贵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用Safari联调Hybrid APP</title>
    <link href="http://yoursite.com/2018/01/30/safair-test-webapp/"/>
    <id>http://yoursite.com/2018/01/30/safair-test-webapp/</id>
    <published>2018-01-30T10:07:08.000Z</published>
    <updated>2018-01-30T10:09:30.557Z</updated>
    
    <content type="html"><![CDATA[<p>随着<a href="https://baike.baidu.com/item/hybrid%20app/270520" target="_blank" rel="noopener">Hybrid APP</a>的流行，对其调试变得必不可少。使用Xcode我们能看到的仅仅是WebView，要想进一步查看里面的a标签、button和其他元素，Xcode是心有余而力不足。但是不用担心，Safari的调试功能能够弥补Xcode的不足，让你能够更方便地调试此类APP。要想使用Safari来调试，你要做的有三步：  </p>
<ol>
<li>配置Safari。</li>
<li>配置iPhone</li>
<li>开始调试</li>
</ol>
<p>接下来就详细对此功能进行解释。</p>
<h4 id="1-配置Safari"><a href="#1-配置Safari" class="headerlink" title="1.配置Safari"></a>1.配置Safari</h4><p>打开Safari，查看菜单栏里面是否有<strong>“开发”</strong>这个菜单，如果有，你的Safari就已经配置好了。如果没有，你要做的操作就是：打开Safari的偏好设置，然后设置高级选项里面选中“在菜单栏中显示开发菜单”。具体看图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/test-web-app-by-safari/safari-high.png" alt="Safari偏好设置"><br>设置完成。</p>
<h4 id="2-配置iPhone"><a href="#2-配置iPhone" class="headerlink" title="2.配置iPhone"></a>2.配置iPhone</h4><p>打开系统设置，然后找到Safari 浏览器,点击高级选项，然后打开“JavaScript”和“Web检查器”即可。具体看图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/test-web-app-by-safari/phone-setting.png" alt="手机对Safari App的设置"><br>到此，iPhone配置成功。</p>
<h4 id="3-开始调试"><a href="#3-开始调试" class="headerlink" title="3.开始调试"></a>3.开始调试</h4><p>设置好前两个步骤后，将手机和电脑使用数据线连接。打开电脑上Safari，然后打开开发菜单，你就会看到你的手机(和你的电脑名称挨着)。此时打开你的Hybrid APP，你就可以调试你的APP了。如图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/test-web-app-by-safari/safari-iphone.png" alt="Safari查看App加载网页"><br>点击你要调试的网页域名，即可弹出调试页面，这个页面的具体功能就自己摸索吧，和网页开发时调试页面差不多。如下图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/test-web-app-by-safari/webpagechecker.png" alt="查看某个页面"><br>到此，你就完成了如何使用Safari进行调试。</p>
<h4 id="几点需要知道的"><a href="#几点需要知道的" class="headerlink" title="几点需要知道的"></a>几点需要知道的</h4><ol>
<li>根据测试，手机端的Safari可以直接连接到电脑上查看加载网页的代码。开发过程中的Hybrid APP也可以通过此方式查看。已经上线的Hybrid APP无法通过此种方式查看。所以在要想通过此方式调试，一定要用Debug包进行调试。</li>
<li>如果在Safari开发菜单中看不到你的手机，那就看看步骤二是否正确配置。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>随着H5和CSS3的进一步发展，Hybrid APP变得更加火爆，具有Native APP的良好交互，又有Web APP跨平台开发的优势，而且需求更新版本不必每次都更新APP。<br>在未来，你看到的手机端APP不一定就是原生的，而是Web，更让人疯狂的是你还无法分辨是否是原生还是Web。<br>所以，移动开发的小伙伴，为了你的未来，多学学前端也是很有必要的。</p>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>转载请注明来源：<a href="http://supermokey.com/2018/01/30/safair-test-webapp/" target="_blank" rel="noopener">http://supermokey.com/2018/01/30/safair-test-webapp/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着&lt;a href=&quot;https://baike.baidu.com/item/hybrid%20app/270520&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hybrid APP&lt;/a&gt;的流行，对其调试变得必不可少。使用Xcode我们能看到的仅仅是
    
    </summary>
    
    
      <category term="Safari" scheme="http://yoursite.com/tags/Safari/"/>
    
      <category term="调试" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>小程序支持打开移动应用到底是怎么回事？</title>
    <link href="http://yoursite.com/2018/01/27/miniprogram-open-app/"/>
    <id>http://yoursite.com/2018/01/27/miniprogram-open-app/</id>
    <published>2018-01-27T03:09:37.000Z</published>
    <updated>2018-01-27T03:13:42.034Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从苹果官方微信号<strong>微信公共平台</strong>发布的文章<a href="https://mp.weixin.qq.com/s/DkbDa2506-dJQ8HY6JFfBg" target="_blank" rel="noopener">《小程序支持打开移动应用》</a>来看，小程序新增了两个功能：  </p>
<ol>
<li>支持打开移动应用    </li>
<li>标题栏区域开放自定义</li>
</ol>
<p>针对第二个功能，就是开发者可以自定义小程序菜单栏的颜色风格，根据需求，对小程序菜单外的标题区域进行自定义，比如设置标题区域的颜色。这里主要介绍一下支持打开移动应用的功能。   </p>
<h4 id="支持打开移动应用"><a href="#支持打开移动应用" class="headerlink" title="支持打开移动应用"></a>支持打开移动应用</h4><p>乍一看其实有点标题党的行为，支持打开移动应用？<br>让我想到的是我可以用小程序打开任何移动应用？（答案是不能）<br>那我是不是可以打开自己的App？（答案是有限制性地打开）<br>是不是可以打开系统自带的浏览器？（答案是不能）<br>是不是可以打开第三方的移动应用呢？（答案也是不能）</p>
<p>其实，小程序打开移动应用有一条硬性要求：<strong>从移动应用分享至小程序的页面，用户访问时支持打开来源应用。</strong>接下来进一步解读一下这条要求。    </p>
<p>大部分程序都有微信分享功能，我们常做的就是将一个图片、一段文字亦或是一个URL链接进行分享，可以分享给好友（包括群）、朋友圈或者是添加到个人收藏，如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/wechatshare.png" alt="微信分享"><br>我们还可以分享小程序，如图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/shareminiprogram.png" alt="小程序分享"><br>上面是一个抢票软件（智行）分享到微信的一个小程序，好友可以点击小程序帮忙加速。按照官方文章的说法，分享到微信的小程序里面如果有一个按钮，实现如下：   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"launchApp"</span> <span class="attr">app-parameter</span>=<span class="string">"wechat"</span> <span class="attr">binderror</span>=<span class="string">"launchAppError"</span>&gt;</span>打开APP<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么当点击此按钮时，就会打开源App。在其他情况下是无法打开的，这里给出了一张能否打开移动APP的图解：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/launch-app.png" alt="launch-app"><br>这里小程序给出一个场景值概念，只有场景值为1036（还有个状态值true或false，它决定是否能够打开APP。场景值为1036，状态值为true）的小程序，才能够打开源APP，即<strong>小程序不能打开任何App，只能跳回分享小程序卡片的APP</strong>。官方文档也对这个标识做了解释：</p>
<blockquote>
<p>在小程序的生命周期内，这个状态的初始值为 false，之后会随着小程序的每次打开（无论是启动还是切到前台）而改变：<br>1.当小程序从 1036（App 分享消息卡片） 打开时，该状态置为 true。<br>2.当小程序从 1089（微信聊天主界面下拉）或 1090（长按小程序右上角菜单唤出最近使用历史）的场景打开时，该状态不变，即保持上一次打开小程序时该状态的值。<br>3.当小程序从非 1036/1089/1090 的场景打开，该状态置为 false。    </p>
</blockquote>
<p>针对第二条，1089和1090那个，我的理解是小程序类似于移动APP，它并没有关闭，而是在后台，所以1089和1090打开小程序只是把小程序唤到前台，所以小程序状态不变。状态如果为true，也可以打开移动APP。<br>以上便是对小程序打开移动应用的介绍，接下来看一下具体代码实现。     </p>
<h4 id="代码实现分享小程序打开移动应用（iOS版本，Android类似）"><a href="#代码实现分享小程序打开移动应用（iOS版本，Android类似）" class="headerlink" title="代码实现分享小程序打开移动应用（iOS版本，Android类似）"></a>代码实现分享小程序打开移动应用（iOS版本，Android类似）</h4><p>首先要做的就是新建一个工程，然后集成微信分享，具体如何集成可以参见<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417694084&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">官网集成文档</a>，集成之后，在页面添加一个按钮，触发实现如下：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (IBAction)openSmallProgramAction:(id)sender &#123;</div><div class="line">    //分享小程序的实现</div><div class="line">    WXMiniProgramObject *wxMiniObject = [WXMiniProgramObject object];</div><div class="line">    wxMiniObject.userName = @&quot;gh_*************&quot;;</div><div class="line">    wxMiniObject.path = @&quot;pages/index/index&quot;;</div><div class="line">	//</div><div class="line">    WXMediaMessage *message = [WXMediaMessage message];</div><div class="line">    message.title = @&quot;我是小程序&quot;;</div><div class="line">    message.description = @&quot;我是用来测试打开App的小程序&quot;;</div><div class="line">    message.mediaObject = wxMiniObject;</div><div class="line">    </div><div class="line">    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</div><div class="line">    req.message = message;</div><div class="line">    req.scene = WXSceneSession;</div><div class="line">    [WXApi sendReq:req];</div><div class="line">   //原来做分享的实现</div><div class="line">//    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];</div><div class="line">//    req.text = @&quot;分享的内容&quot;;</div><div class="line">//    req.bText = YES;</div><div class="line">//    req.scene = WXSceneSession;</div><div class="line">//    [WXApi sendReq:req];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是所有的App都可以用上面的实现方式分享小程序么吗？答案是否定的。看官方文档的说法：   </p>
<blockquote>
<p>移动应用分享功能支持小程序类型分享，要求发起分享的APP与小程序属于同一微信开放平台帐号。支持分享小程序类型消息至好友会话，不支持“分享至朋友圈”及“收藏”。</p>
</blockquote>
<p>也就是说小程序分享是有限制的：    </p>
<ol>
<li>发起分享的App与小程序属于同一微信开放平台账号    </li>
<li>只支持分享小程序类型消息至好友会话（SendMessageToWXReq的scence只支持WXSceneSession）       </li>
</ol>
<p>经过测试，一个账号不能同时注册<a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">微信开放平台</a>和<a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">微信公众平台</a>。也就是说：如果你的账号注册了微信开放平台，那么该账号就不能再次注册微信公众平台。</p>
<blockquote>
<p>微信开放平台放的是移动APP。<br>微信公众平台放的是小程序。    </p>
</blockquote>
<p>那官方所说的属于同一微信开放平台账号就不是一个账号下既有APP又有小程序（因为小程序是在微信公众平台开发的）。打开微信开放平台页面之后，第一条就好理解了：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/openwechat.png" alt="移动应用"><br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/openwechatminiprogram.png" alt="小程序"><br><strong>如果你想要在移动APP内分享小程序，你必须在该APP所在的微信开放平台账号下绑定微信小程序，这样才可以在APP中实现小程序分享。这就是官方所说的APP和小程序属于同一微信开放平台账号。</strong><br><strong>那么APP怎么知道分享哪个小程序的？ 或者说APP是怎么和小程序关联的呢？</strong><br>这就要看上面的那段代码（前提是你把小程序和APP放到了同一开放平台账号下），其中有一行：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wxMiniObject.userName = @&quot;gh_*************&quot;;</div></pre></td></tr></table></figure>
<p>该userName就是小程序的userName，你可以登录<a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">微信公众号平台|小程序</a>，然后在设置—&gt;基本设置中查看，里面有个原始id，就是小程序的userName。<br>这样你就将APP的分享和小程序关联起来了。<br>还有一个问题：<strong>分享的小程序如何打开指定的页面呢？</strong><br>这就要看另一行代码：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wxMiniObject.path = @&quot;pages/index/index&quot;;</div></pre></td></tr></table></figure>
<p>你需要设置一下小程序的path，这个path的页面就是你点击分享的小程序打开的页面。这里看一张小程序开发工具的图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/minicode.png" alt="小程序代码段"><br>pages所指的就是页面，例如上图的pages文件夹包含了detail和index和logs三个页面，其中：<br>index：指代的是信用卡列表页。<br>detail：指代的是点击列表某个item进入的详情页。<br>logs：日志页面<br>所以如果你想跳转到详情页，那么你在设置wxMiniObject的path时就应该写成“pages/detail/detail”。这样就实现了点击分享的小程序进入指定的页面了（如果页面需要参数你也要在分享时传过去）。</p>
<blockquote>
<p>wxml：相当于html<br>wxss：相当于css<br>这里其实是微信小程序自己定义了后缀。    </p>
</blockquote>
<p>这个时候你分享的小程序场景值为1036，且状态为true，如果此时你小程序里面有open-type为“launchApp”的button，点击button你就会跳回你的移动APP啦。如果想给APP回传内容，可以设置app-parameter。就像这个小按钮：    </p>
<pre><code class="html"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"launchApp"</span> <span class="attr">app-parameter</span>=<span class="string">"wechat"</span> <span class="attr">binderror</span>=<span class="string">"launchAppError"</span>&gt;</span>打开APP<span class="tag">&lt;/<span class="name">button</span>&gt;</span>
</code></pre>
<p>到此，我想你应该大概了解小程序支持打开移动应用到底是怎么回事了。   </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>小程序并不是支持打开所有移动APP，就算是同一个微信开放平台账号下面的移动APP和小程序，小程序也不一定可以打开，具体还要看场景。</p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>小程序支持跳转移动APP是很大的进步，在小程序以后的进一步完善中，它应该会朝着APP直接打开小程序方向迈进，而不仅仅是通过分享打开小程序。未来我们也许会实现点击移动APP里面的某个按钮直接打开某个小程序，然后在小程序操作完成之后再次返回到移动APP。（例如微信支付，可以从移动APP跳转到小程序进行微信支付，支付成功后直接返回移动APP）</p>
<h4 id="附参考"><a href="#附参考" class="headerlink" title="附参考"></a>附参考</h4><p>1.<a href="https://mp.weixin.qq.com/s/DkbDa2506-dJQ8HY6JFfBg" target="_blank" rel="noopener">小程序支持打开移动应用</a><br>2.<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/launchApp.html" target="_blank" rel="noopener">launchApp(OBJECT)</a> </p>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>转载请注明来源：<a href="http://supermokey.com/2018/01/27/miniprogram-open-app/" target="_blank" rel="noopener">http://supermokey.com/2018/01/27/miniprogram-open-app/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;从苹果官方微信号&lt;strong&gt;微信公共平台&lt;/strong&gt;发布的文章&lt;a href=&quot;https://mp.weixin.qq.com/
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信分享" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>记录一次APP的转让流程</title>
    <link href="http://yoursite.com/2018/01/12/transfer-app/"/>
    <id>http://yoursite.com/2018/01/12/transfer-app/</id>
    <published>2018-01-12T08:02:30.000Z</published>
    <updated>2018-01-12T08:03:42.973Z</updated>
    
    <content type="html"><![CDATA[<p>由于业务需要，需要将开发的App从一个账号(A账号)转移到另一个账号（B账号），这里简单介绍一下转让流程。主要包括两大步骤：      </p>
<ol>
<li>转让方（A账号）提出转让申请    </li>
<li>接收方（B账号）接受转让App    </li>
</ol>
<p>如果不想看这篇流程，可以直接查看官方给出的一些资料，详情可参见<a href="http://itunespartner.apple.com/cn/apps/faq/App%20Transfer_Requirements" target="_blank" rel="noopener">这里</a>。还可以看一下苹果官方就如何转让App给出的<a href="https://github.com/ScottZg/MarkDownResource/blob/master/transfer_app/%E5%AE%A2%E6%9C%8D%E4%BA%BA%E5%91%98%E5%9B%9E%E5%A4%8D%E5%A6%82%E4%BD%95%E8%BD%AC%E8%AE%A9App.pdf" target="_blank" rel="noopener">回复邮件</a>。<br>如果不想看上面的东西，那就继续往下浏览。<br>现在具体说一下两个步骤以及中间遇到的坑。    </p>
<h4 id="1-转让方（A账号）提出转让申请"><a href="#1-转让方（A账号）提出转让申请" class="headerlink" title="1. 转让方（A账号）提出转让申请"></a>1. 转让方（A账号）提出转让申请</h4><p>首先打开iTunes Connect，然后找到你要转让的App，点击App信息，如下图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/app_info.png" alt="App信息"><br>点击转让App，就会进入一个查看你的App是否支持转让的页面：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/transport_conditation_faile.png" alt="是否支持条件判断页面"><br>我在转让的过程中出现这种情况，提示“TestFlight Beta 版测试”选项没有通过，按照他的提示，你需要把TestFlight里面所有的构建版本都移除，并且清空测试信息里面的所有数据。因为我们一直使用TestFlight做beta测试分发，所以需要将这些构建版本删除，包括测试信息里面的数据。删除构建版本的方法如下，先找到这个页面：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/test-beta-app.png" alt="删除构建版本"><br>然后点击构建版本进入新的页面：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/set_unuse.png" alt="设置过期按钮"><br>点击“将构建版本设为过期”,然后确认之后你就将构建版本3删除了。按照上述方法，你要把所有的构建版本都删除最终看到这种页面为止：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/no_build.png" alt="无构建版本"><br>记得构建版本下面的App信息中的测试信息内容也要清空（如果设置了多语言，也需要将其他语言里面的测试信息清空）。<br><strong>这里可能是由于缓存的问题，我把所有清空完成之后再次进入是否支持转让页面时，依然提示“TestFlight Beta 版测试”选项没有通过。我退出登录，然后清除了一下缓存，再次进入发现一切都已经ok了。</strong><br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/transport_conditation.png" alt="满足条件"><br>接下来点击继续，会打开如下页面：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/teamid.png" alt="填写接收者信息"><br>接下来按照要求填写即可。然后点击继续进入确认页面。查看转让信息以及转让协议，最后统一条款在确认转让即可。这是便会展示如下页面信息：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/result.png" alt="请求转让结束"></p>
<p>到此对账号A的操作完成。</p>
<h4 id="2-接收方（B账号）接受转让APP"><a href="#2-接收方（B账号）接受转让APP" class="headerlink" title="2.接收方（B账号）接受转让APP"></a>2.接收方（B账号）接受转让APP</h4><p><strong>接下来你要做的不是等待，而是让B账号所有人在itunesconnect上登录B账号</strong>，登录完成之后你会看到如下页面：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/accept_itunesconnect.png" alt="B账号登录后的页面"><br>然后点击“协议、税务和银行业务”，进入之后，然后按照下图的箭头点击：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/review.png" alt="review"><br>然后会让你填写一些信息，具体内容如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/transfer_app/aggrement1.jpg" alt="agrement"><br>这里按照要求填写响应内容即可。  这里我遇到的一个小问题就是手机号码加上了“+86”依然报错，最后多尝试了几次（在86后面+空格，将空格删掉等），才消除错误。<br>然后点选同意显示的条款，最后点击”Accept”按钮就ok了。这时你会发现此App已经成功转让到B账号了。<br>注：App Store里面显示的开发者更新会有延迟，我的是转让成功10分钟后才展示B账号的信息。        </p>
<h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>由于你的App已经从A账号转让到了B账号，所以你发布新版本的时候就需要通过B账号来打包了。<br>这时如果该App有推送，你需要创建推送证书，然后更新证书。转让并不包含证书和配置文件。<br>你打包的时候也可能会遇到这种问题：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Potential Loss of Keychain Access - The previous version of software has an application-identifier value of ['sdfasdfsd.com.xxxx.yyyy'] and the new version of software being submitted has an application-identifier of ['ggthtrhtf.com.xxxx.yyyy']. This will result in a loss of keychain access.</div></pre></td></tr></table></figure>
<p>它的意思是由于Team变更，可能存在潜在的钥匙串访问丢失。这个只是一个警告。具体可以参见<a href="https://developer.apple.com/library/content/qa/qa1726/_index.html" target="_blank" rel="noopener">Resolving the Potential Loss of Keychain Access warning</a>。里面会告诉你什么时候可以忽略这个警告，什么时候不能忽略以及如何解决这个问题。     </p>
<p>还有关于推送证书，你将新版本发布之后需要将推送证书更新一下。因此这里可能会导致的问题就是同步问题，因为你App当前可用版本有可能包括老版本和新版本，所以发送的推送有的时候可能收不到。这里可以做个强制更新。   </p>
<p>如果App里面包含老账号的信息（例如公司名称），需要你将信息更新为B账号的信息。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上便是对转让App的简单记录。总体来说转让一款App并不需要我们花费很长时间，一般10分钟内就能搞定。有什么疑问随时沟通（Q群：206613455）。</p>
<h4 id="Reference-Resource"><a href="#Reference-Resource" class="headerlink" title="Reference Resource"></a>Reference Resource</h4><ol>
<li><a href="http://itunespartner.apple.com/cn/apps/faq/App%20Transfer_Requirements" target="_blank" rel="noopener">官方Resources and Help</a></li>
<li><a href="https://developer.apple.com/contact/phone/cn/" target="_blank" rel="noopener">各种苹果官方联系电话</a>   </li>
<li><a href="https://developer.apple.com/library/content/qa/qa1726/_index.html" target="_blank" rel="noopener">Resolving the Potential Loss of Keychain Access warning</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于业务需要，需要将开发的App从一个账号(A账号)转移到另一个账号（B账号），这里简单介绍一下转让流程。主要包括两大步骤：      &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转让方（A账号）提出转让申请    &lt;/li&gt;
&lt;li&gt;接收方（B账号）接受转让App    &lt;/li&gt;
&lt;/
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="App转让" scheme="http://yoursite.com/tags/App%E8%BD%AC%E8%AE%A9/"/>
    
  </entry>
  
  <entry>
    <title>Runtime那些事</title>
    <link href="http://yoursite.com/2018/01/08/runtime/"/>
    <id>http://yoursite.com/2018/01/08/runtime/</id>
    <published>2018-01-08T09:03:10.000Z</published>
    <updated>2018-01-12T07:58:48.642Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从字面意思看，就是运行时。但是这个运行时究竟什么意思？可以把它理解成：不是在编译期也不是在链接期，而是在运行时。那究竟在运行期间做了什么呢？按照苹果官方的说法，就是把一些决策（方法的调用，类的添加等）推迟，推迟到运行期间。只要有可能，程序就可以动态的完成任务，而不是我们在编译期已经决定它要完成什么任务。这就意味了OC不仅仅需要编译器，还需要一个运行时的系统来支撑。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>接下来就对Runtime做一个系统的介绍，主要内容包括：   </p>
<ol>
<li>简介   </li>
<li>涉及到的数据结构    </li>
<li>runtime.h解析    </li>
<li>如何可以触及到RunTime?       </li>
<li>消息  </li>
<li>动态消息解析  </li>
<li>消息转发  </li>
<li>Runtime的使用场景  </li>
</ol>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>根据前言，你已经了解了Runtime大概是个什么鬼，在OC发展历程中，它主要有两个版本：Legacy和Modern。Legacy版本采用的是OC1.0版本；Modern版本采用的OC2.0版本，而且相比Legacy也添加了一些新特性。最明显的区别在于：  </p>
<ul>
<li>在legacy版本，如果你改变了类的布局，那么你必须重新编译继承自它的类。    </li>
<li>在modern版本，如果你改变了类的布局，你不必重新编辑继承自它的类。</li>
</ul>
<h5 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h5><p>iPhone的应用程序以及OS X v10.5版本的64位机器使用的是modern版本的runtime。<br>其他（OS X桌面应用32位程序）使用的是legacy版本的runtime。</p>
<h4 id="2-涉及到的数据结构"><a href="#2-涉及到的数据结构" class="headerlink" title="2.涉及到的数据结构"></a>2.涉及到的数据结构</h4><p>这里主要介绍一下在runtime.h里面涉及到的一些数据结构。</p>
<h5 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h5><p>Ivar从字面意思来讲，它就是代表的实例变量，它也是一个结构体指针，包含了变量的名称、类型、偏移量以及所占空间。</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><p>选择器，每个方法都有自己的选择器，其实就是方法的名字，但是不仅仅是方法的名字，在objc.h中，我们可以看到它的定义：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/// An opaque type that represents a method selector.一个不透明类型，用来代表一个方法选择器</div><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>由定义可知它是一个objc_selector的结构体指针，尴尬的是在runtime源码中并没有找到该结构体。猜想它内部应该就是一个char 的字符串。<br>你可以使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;%s&quot;,@selector(description));  //%s用来输出一个字符串</div></pre></td></tr></table></figure>
<p>打印出来description。<br>在这里你可以把它理解成一个选择器，可以标识某个方法。</p>
<h5 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h5><p>它是一个函数指针，指向方法的实现，在objc.h里面它的定义是这样的： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// A pointer to the function of a method implementation. </div><div class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</div><div class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </div><div class="line">#else</div><div class="line">typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id是一个我们经常使用的类型，可用于作为类型转换的中介者。它类似于Java里面的Object，可以转换为任何的数据类型。它在objc.h里面是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// Represents an instance of a class.</div><div class="line">struct objc_object &#123;</div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/// A pointer to an instance of a class.</div><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure>
<p>它其实是一个objc <em> object的结构体指针，而在后面将要提到的Class其实是个objc </em> class的指针，而objc _ class是继承自objc _o bject的，因此可以相互转换，这也是为什么id可以转换为其他任何的数据类型的原因。</p>
<h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><p>方法，它其实是一个objc_method的结构体指针,其定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/// An opaque type that represents a method in a class definition.</div><div class="line">typedef struct objc_method *Method;</div><div class="line"></div><div class="line">struct objc_method &#123;</div><div class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</div><div class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</div><div class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就比较好理解了，该结构体包含了方法的名称（SEL），方法的类型以及方法的IMP。</p>
<h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p>它是一个objc_class的结构体指针，在runtime.h中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/// An opaque type that represents an Objective-C class.一个不透明类型，代表OC的类</div><div class="line">typedef struct objc_class *Class;</div><div class="line"></div><div class="line">struct objc_class &#123;</div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</div><div class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>该结构体中各部分介绍如下：    </p>
<ul>
<li>isa：是一个Class类型的指针，每个对象的实例都有isa指针，他指向对象的类。而Class里面也有个isa指针，它指向meteClass(元类)，元类保存了类方法的列表。    </li>
<li>name：对象的名字    </li>
<li>version：类的版本号，必须是0    </li>
<li>info：供运行期间使用的位标识   </li>
<li>instance_size：该类的实例大小  </li>
<li>ivars：成员变量数组,包含了该类包含的成员变量    </li>
<li>methodLists：包含方法的数组列表，也是一个结构体，该结构体里面还包含了一个obsolete的指针，表示废弃的方法的列表    </li>
<li>cache：缓存。这个比较复杂，在后面会提到，这里先忽略。     </li>
<li>protocols：协议列表，也是一个数组</li>
</ul>
<p>而在objc-runtime-new.h中，你会发现这样的定义（在runtime中并没有完全暴露objc_class的实现）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;             // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class="line"></div><div class="line">    class_rw_t *data() &#123; </div><div class="line">        return bits.data();</div><div class="line">    &#125;</div><div class="line">    //其他的省略</div></pre></td></tr></table></figure>
<p>其实objc <em> class继承自objc </em> object。所以这也说明了为什么id能够转换为其他的类型。</p>
<h4 id="3-runtime-h解析"><a href="#3-runtime-h解析" class="headerlink" title="3.runtime.h解析"></a>3.runtime.h解析</h4><p>我们先看一下在usr/include/objc/runtime.h，这个是任何一个工程都可以直接找到的，它是SDK的一部分。主要定义了以下内容：     </p>
<ol>
<li>定义了一些类型，例如Method/Ivar/Category等，还有一些结构体。    </li>
<li>函数。函数里面有分了几大类：    <ul>
<li>关于对象实例的方法，例如object <em> getClass、object </em> setClass以及object _ getIvar等。这些函数大<strong>多以object开头</strong>。 用来获取属性或者对对象进行操作。       </li>
<li>获得类定义的方法，例如objc <em> getClass/objc </em> getMetaClass等，这些方法更多的是获取Class或者在Class级别上进行操作。  <strong>多以objc开头</strong>   </li>
<li>和类相关的方法。例如class <em> getName/class </em> isMetaClass等，这些更多的是获取Class的一些属性。比如该类的属性列表、方法列表、协议列表等。传参大多为Class。  <strong>多以class开头</strong>    </li>
<li>实例化类的一些方法。例如class _ createInstance方法，就是相当于平时的alloc init。     </li>
<li>添加类的方法。例如你可以使用这些方法冬天的注册一个类。使用objc <em> allocateClassPair创建一个新类，使用 objc </em> registerClassPair对类进行注册      </li>
<li>等等。。。    </li>
</ul>
</li>
<li>另外就是一些废弃的方法和类型。</li>
</ol>
<h4 id="4-如何可以触及到RunTime"><a href="#4-如何可以触及到RunTime" class="headerlink" title="4. 如何可以触及到RunTime?"></a>4. 如何可以触及到RunTime?</h4><p>有三种不同的方式可以让OC编程和runtime系统交互。   </p>
<h5 id="OC源代码"><a href="#OC源代码" class="headerlink" title="OC源代码"></a>OC源代码</h5><p>大多数情况下，我们写的OC代码，其实它底层的实现就是runtime。runtime系统在背后自动帮我们处理了操作。例如我们编译一个类，编译器器会创建一个结构体，然后这个结构体会从类中捕获信息，包括方法、属性、Protocol等。</p>
<h5 id="NSObject的一些方法"><a href="#NSObject的一些方法" class="headerlink" title="NSObject的一些方法"></a>NSObject的一些方法</h5><p>在Foundation框架里面有个NSObject.h，在usr/include/objc里面也有一个NSObject.h。而我们平时用到的类的基类是/usr/include/objc里面的这个NSObject.h，Foundation里面的NSObject.h只是NSObject的一个Category。所以这里我们更关注一下/usr/include/objc里面的NSObject.h。<br>由于大多数对象都是NSObject的子类，所以在NSObject.h里面定义的方法都可以使用。<br>在这些方法里面，有一些方法能够查询runtime系统的信息，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isKindOfClass:(Class)aClass;   //用来检测一个对象是否是某各类的实例对象，aClass也有可能是父类，同样可以检测出来。</div><div class="line">- (BOOL)isMemberOfClass:(Class)aClass;   //而该方法只能检测一个对象是否是某各类的实例对象。但如果aClass不能为该类的父类，如果是父类则该方法返回NO</div><div class="line"></div><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</div><div class="line"></div><div class="line">- (BOOL)conformsToProtocol:(Protocol *)aProtocol;</div><div class="line"></div><div class="line">- (IMP)methodForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>这里用代码对isKindOfClass和isMemberOfClass做个简单介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//stu是Student的实例对象，Student的父类为Person，Person的父类为NSObject。</div><div class="line">[stu isKindOfClass:[Student class]];    //YES</div><div class="line">[stu isKindOfClass:[Person class]];    //YES</div><div class="line">[stu isKindOfClass:[NSObject class]];   //YES</div><div class="line"></div><div class="line">[stu isMemberOfClass:[Student class]];    //YES</div><div class="line">[stu isMemberOfClass:[Person class]];    //NO</div><div class="line">[stu isMemberOfClass:[NSObject class]];   //NO</div></pre></td></tr></table></figure>
<p>我们可以在objc源代码中的NSObject.mm中看到相应的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return object_getClass((id)self) == cls;</div><div class="line">&#125;</div><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从具体实现可知，为什么isKindOfClass能够检测出superclass。另外，在NSObject.h中，并没有看到两个方法的类方法声明，但是在实现里面却包含了类方法的实现。这里有个疑问：<strong>为什么没有对外声明的两个类方法依然可以在外部调用呢？（比如我可以直接使用[Student isMemberOfClass:[NSObject class]]）</strong>。<br>这里还用到了class方法，这个方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;aClass.self&apos; instead&quot;);</div><div class="line"></div><div class="line">- (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;type(of: anObject)&apos; instead&quot;);</div><div class="line"></div><div class="line">+ (Class)class &#123;   //返回当前的self</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Class)class &#123;</div><div class="line">    return object_getClass(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重要的是理解self究竟代表着什么：   </p>
<ol>
<li>当self为实例对象的时候，[self class] 和 object_getClass(self)是等价的。object_getClass([self class])得到的是元类。    </li>
<li>当self为类对象的时候，[self class]返回的是自身，还是self。object_getClass(self) 与object_getClass([self class])等价。拿到的是元类。</li>
</ol>
<h5 id="Runtime函数"><a href="#Runtime函数" class="headerlink" title="Runtime函数"></a>Runtime函数</h5><p>runtime系统其实就是一个动态共享的Library，它是由在/usr/include/objc目录的公共接口中的函数和数据结构组成。<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/runtime/objc.png" alt="runtime"></p>
<h4 id="5-消息"><a href="#5-消息" class="headerlink" title="5. 消息"></a>5. 消息</h4><p>在Objective-C中，消息直到运行时才将其与消息的实现绑定，编译器会将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message];</div></pre></td></tr></table></figure>
<p>转换成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver,selector);   //1</div><div class="line"></div><div class="line">objc_msgSend(receiver,selector,arg1,arg2,...);  //2</div></pre></td></tr></table></figure>
<p>如果包含参数，那么就会执行2方法。其实除了该方法，还有以下几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objc_msgSend_stret    </div><div class="line">objc_msgSendSuper</div><div class="line">objc_msgSendSuper_stret</div></pre></td></tr></table></figure>
<p>当想一个对象的父类发送message时，会使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSendSuper</div></pre></td></tr></table></figure>
<p>如果方法的返回值是一个结构体，那么就会使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_msgSend_stret</div><div class="line">objc_msgSendSuper_stret</div></pre></td></tr></table></figure>
<p>这里我们可以打开<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc源码</a>，然后你会发现里面有多个.s文件：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/runtime/objc_msg_diff.png" alt="objc_msg_diff"><br>这里之所以有objc-msg-类的不同文件，我猜想应该是对不同的CPU指令集(指令不一样)做了分别处理。因为这些.s文件名称中包含的是不同的arm指令集。而且打开.s文件你会发现里面的实现是汇编语言，所以苹果为了效率还是蛮拼的，直接用汇编语言实现。<br>其中就能找到objc _ msgSend的实现（objc-msg-i386.s中）：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/runtime/objc_msgSend.png" alt="objc_msgSend"><br>虽然对汇编了解不是太多，但是这个文件中的注释很详细，从注释可以看出objc_msgSend方法的执行过程： </p>
<ol>
<li>先加载receiver和selector到寄存器，然后判断receiver是否为空,如果为空，则函数执行结束；       </li>
<li>如果receiver不为空，开始搜索缓存，查看方法缓存列表里面是否有改selector，如果有则执行；    </li>
<li>如果没有缓存，则搜索方法列表，如果在方法列表中找到，则跳转到具体的imp实现。没有则执行结束。</li>
</ol>
<h5 id="使用了隐藏参数"><a href="#使用了隐藏参数" class="headerlink" title="使用了隐藏参数"></a>使用了隐藏参数</h5><p>在发送一个消息的时候，会被编译成objc_msgSend，此时该消息的参数将会传入objc_msgSend方法里面。除此之外，还会包含两个隐藏的参数：    </p>
<ol>
<li>receiver    </li>
<li>method的selector    </li>
</ol>
<p>这两个参数在上面也有提到。其中的receiver就是消息的发送方，而selector就是选择器，也可以直接用 <em> cmd来指代( </em> cmd用来代表当前所在方法的SEL)。之所以隐蔽是因为在方法声明中并没有被明确声明，在源代码中我们仍然可以引用它们。<br>hexo</p>
<h5 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h5><p>我们每次发送消息都会走objc_msgSend()方法，那么有没有办法避开消息绑定直接获取方法的地址并调用方法呢？答案当然是有的。我们上面简单介绍了IMP，其实我们可以使用NSObject的 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (IMP)methodForSelector:(SEL)aSelector;</div><div class="line">```    </div><div class="line">方法，通过该方法获得IMP，然后调用该方法。但是避开消息绑定而直接调用的使用并不常见，但是如果你要多次循环调用的话，直接获取方法地址并调用不失为一个省时操作。看下面的代码：</div><div class="line"></div><div class="line">```objective-c</div><div class="line"> void (*setter)(id,SEL,BOOL);</div><div class="line">    setter = (void(*)(id,SEL,BOOL))[stu2 methodForSelector:@selector(learning)];</div><div class="line">    NSDate *startDate = [NSDate date];</div><div class="line">    for (int i = 0;i&lt;100000;i++) &#123;</div><div class="line">        setter(stu2,@selector(learning),YES);</div><div class="line">    &#125;</div><div class="line">    double deltaTime = [[NSDate date] timeIntervalSinceDate:startDate];</div><div class="line">    NSLog(@&quot;----%f&quot;,deltaTime);</div><div class="line">    </div><div class="line">    NSDate *startDate1 = [NSDate date];</div><div class="line">    for (int i = 0;i&lt;100000;i++) &#123;</div><div class="line">        [stu2 learning];</div><div class="line">    &#125;</div><div class="line">    double deltaTime1 = [[NSDate date] timeIntervalSinceDate:startDate1];</div><div class="line">    NSLog(@&quot;----%f&quot;,deltaTime1);</div></pre></td></tr></table></figure>
<p>你可以自行跑一下，看一下时间差异。你会发现：获取方法地址直接调用更省时间，但请注意使用场景。</p>
<h4 id="6-动态消息解析"><a href="#6-动态消息解析" class="headerlink" title="6. 动态消息解析"></a>6. 动态消息解析</h4><p>这里介绍一下如果动态地提供方法的实现。  </p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>在开发过程中，你可能想动态地提供一个方法的实现。比如我们对一个对象声明了一个属性，然后我们使用了 @dynamic 标识符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>该标识符的目的就是告诉编译器：和这个属性相关的getter和setter方法会动态地提供（当然你也可以直接手动在代码里面实现）。这个时候你就会用到NSObject.h里面的两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div></pre></td></tr></table></figure>
<p>来提供方法的实现。<br>其实OC方法就是一个简单的C函数，它至少包含了两个参数self和 _ cmd，你可以自己声明一个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</div><div class="line">	//这里是方法的具体实现</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时我们可以在声明属性的类中实现上面提到的两个方法（一个是解析类方法，一个是解析实例方法），例如我在Person里面这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic address;   //也就意味着我们需要手动/动态实现该属性的getter和setter方法。</div></pre></td></tr></table></figure>
<p>你会发现当我们运行下面的代码时，程序会crash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   Person *zhangsan = [[Person alloc] init];</div><div class="line">    zhangsan.address = @&quot;he nan xinxiang &quot;;</div><div class="line">    </div><div class="line">    NSLog(@&quot;%@&quot;,zhangsan.address);</div><div class="line">    </div><div class="line">//    crash reason</div><div class="line">// -[Person setAddress:]: unrecognized selector sent to instance 0x1d4449630</div></pre></td></tr></table></figure>
<p>这里简单的做一个动态方法解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void setter(id self,SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;set address&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSString *selStr = NSStringFromSelector(sel);</div><div class="line">    if ([selStr hasPrefix:@&quot;set&quot;]) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)setter, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们需要自己去实现setAddress: 方法。（这里判断用hasPrefix不太准确，开发者可以自行根据需求调整）。转发消息（下面会讲到）和动态解析是正交的。也就是说一个class有机会再消息转发机制前去动态解析此方法，也可以将动态解析方法返回NO，然后将操作转发给消息转发。</p>
<h5 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h5><p>OC编程也允许我们在程序运行的时候动态去创建和链接一个类或者分类。这些创建的类或者分类将会和运行app前创建的类一样，没有差别。<br>动态加载在开发的过程中可以做好多事情，例如系统设置中的不同模块就是动态加载的。<br>在Cocoa环境中，最经典的就是Xcode，它可以安装不同的插件，这个也是动态加载的方式实现的。</p>
<h4 id="7-消息转发"><a href="#7-消息转发" class="headerlink" title="7. 消息转发"></a>7. 消息转发</h4><p>发送一个消息给对象，如果对象不能处理，那么就会产生错误。然而，在产生错误之前，runtime 系统会给对象第二次机会去处理该消息。这里详细已经在<a href="http://www.cnblogs.com/zhanggui/p/7731394.html" target="_blank" rel="noopener">深入浅出理解消息的传递和转发</a>文章中做了介绍，这里就不再介绍了。   </p>
<h4 id="8-Runtime的使用场景"><a href="#8-Runtime的使用场景" class="headerlink" title="8. Runtime的使用场景"></a>8. Runtime的使用场景</h4><p>Runtime的使用几乎无处不在，OC本身就是一门运行时语言，Class的生成、方法的调用等等，都是Runtime。另外，我们可以用Runtime做一些其他的事情。</p>
<h5 id="字典转换Model"><a href="#字典转换Model" class="headerlink" title="字典转换Model"></a>字典转换Model</h5><p>平时我们从服务端拿到的数据是json字符串，我们可以将其转换成成NSDictionary，然后通过runtime中的一些方法做一个转换：<br>先拿到model的所有属性或者成员变量，然后将其和字典中的key做映射，然后通过KVC对属性赋值即可。更多可参见<a href="http://www.cnblogs.com/zhanggui/p/8177400.html" target="_blank" rel="noopener">class_copyIvarList方法获取实例变量问题引发的思考</a>中的例子。</p>
<h5 id="热更新（JSPatch的实现）"><a href="#热更新（JSPatch的实现）" class="headerlink" title="热更新（JSPatch的实现）"></a>热更新（JSPatch的实现）</h5><p>JSPatch能做到JS调用和改写OC方法的根本原因就是OC是动态语言，OC上的所有方法的调用/类的生成都通过OC Runtime在运行时进行，我们可以根据名称/方法名反射得到相应的类和方法。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class class = NSClassFromString(&quot;UIViewController&quot;);</div><div class="line">id viewController = [[class alloc] init];</div><div class="line">SEL selector = NSSelectorFromString(&quot;viewDidLoad&quot;);</div><div class="line">[viewController performSelector:selector];</div></pre></td></tr></table></figure>
<p>也正是鉴于此，才实现了热更新。</p>
<h5 id="给Category添加属性"><a href="#给Category添加属性" class="headerlink" title="给Category添加属性"></a>给Category添加属性</h5><p>我们可以使用runtime在Category中给类添加属性，这个主要使用了两个runtime钟的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT void</div><div class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy);</div><div class="line"></div><div class="line">OBJC_EXPORT id _Nullable</div><div class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</div></pre></td></tr></table></figure>
<p>具体使用可参见：<a href="https://www.jianshu.com/p/3cbab68fb856" target="_blank" rel="noopener">给分类（Category）添加属性</a>。</p>
<h5 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h5><p>它是改变一个已存在的selector的实现的技术，比如你想将viewDidload方法替换为我们自定义的方法，给系统的方法添加一些需要的功能，来实现某些需求。比如你想跟踪每个ViewController展示的次数，你可以使用该技术重写ViewDidAppear方法，然后做一些自己的处理。可以参见<a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a>里面的讲解。  </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Objective-c本身就是一门冬天语言，所以了解runtime有助于我们更加深入地了解其内部的实现原理。也会把一些看似很难的问题通过runtime很快解决。</p>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p>1.<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a><br>2.<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a><br>3.<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4</a><br>4.<a href="http://www.cnblogs.com/zhanggui/p/7731394.html" target="_blank" rel="noopener">深入浅出理解消息的传递和转发</a><br>5.<a href="http://www.cnblogs.com/zhanggui/p/8177400.html" target="_blank" rel="noopener">class_copyIvarList方法获取实例变量问题引发的思考</a><br>6.<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">JSPatch 实现原理详解</a><br>7.<a href="https://www.jianshu.com/p/3cbab68fb856" target="_blank" rel="noopener">给分类（Category）添加属性</a><br>8.<a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;从字面意思看，就是运行时。但是这个运行时究竟什么意思？可以把它理解成：不是在编译期也不是在链接期，而是在运行时。那究竟在运行期间做了什么呢？
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>class_copyIvarList方法获取实例变量问题引发的思考</title>
    <link href="http://yoursite.com/2018/01/02/class-copyIvarList/"/>
    <id>http://yoursite.com/2018/01/02/class-copyIvarList/</id>
    <published>2018-01-02T07:40:42.000Z</published>
    <updated>2018-01-02T07:44:52.003Z</updated>
    
    <content type="html"><![CDATA[<p>在runtime.h中，你可以通过其中的class_copyIvarList方法来获取实例变量。具体的实现如下（记得导入头文件<objc runtime.h="">）：</objc></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)ivarArray:(Class)cls &#123;</div><div class="line">    unsigned int stuIvarCount = 0;</div><div class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;stuIvarCount);</div><div class="line">    if (stuIvarCount == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:stuIvarCount];</div><div class="line">    for (int i = 0;i&lt;stuIvarCount;i++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">        NSLog(@&quot;%@&quot;,ivarName);</div><div class="line">        [arr addObject:ivarName];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面代码。其中cls就是你要获取实例变量的类，stuIvarCount用来承载要获取类的实例变量的个数。打印出来的ivarName就是cls的实例变量。接下来对这个方法进行解析:<br>首先看一下里面的Ivar,先看一下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/// An opaque type that represents an instance variable.</div><div class="line">typedef struct objc_ivar *Ivar;</div><div class="line"></div><div class="line">struct objc_ivar &#123;</div><div class="line">    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;  //变量名字</div><div class="line">    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;   //变量类型</div><div class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE; //偏移量</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;  //存储空间</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Ivar是一个叫做objc_ivar的结构体指针,其中的 ifdef判断是判断当前设备是否是64位设备，这里可以延伸出一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//判断当前设备是否是64位设备，也可以用这个方法判断是否是32位设备</div><div class="line">- (BOOL)is64Bit &#123;</div><div class="line">#if defined(__LP64__) &amp;&amp; __LP64__</div><div class="line">    return YES;</div><div class="line">#else</div><div class="line">    return NO;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT Ivar _Nonnull * _Nullable</div><div class="line">class_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount) </div><div class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div></pre></td></tr></table></figure>
<p>class_copyIvarList的注释如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/class_copyIvarList/class_copyIvarList.png" alt="class_copyIvarList"><br>它返回的是一个Ivar的数组，这个数组里面包含了你要查看类的所有实例变量，但是不包括从父类继承过来的。如果你传入的类没有实例变量或者改class为Nil,那么该方法返回的就是NULL，count值也就变成了0。有一点需要注意：<strong>你必须使用free()方法将该数组释放</strong>。<br>然后就是通过for循环遍历，通过ivar _ getName拿到ivarName。<br>以上便是对clas_copyIvarList的介绍。<br>它还有一个最常用的使用方式（在开发中经常用到的）：根据字典或者json字符串转化为model，在网络请求返回数据时经常用到。使用方法就是自己写一个基类的model，然后让项目中用到的model都继承自此基类，基类中的关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)zg_modelFromDic:(NSDictionary *)dataDic &#123;</div><div class="line">    id model = [[self alloc] init];  </div><div class="line">    unsigned int count = 0;</div><div class="line">    </div><div class="line">    Ivar *ivarsA = class_copyIvarList(self, &amp;count);</div><div class="line">    if (count == 0) &#123;</div><div class="line">        return model;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0;i &lt; count; i++) &#123;</div><div class="line">        Ivar iv = ivarsA[i];</div><div class="line">        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(iv)];</div><div class="line">        ivarName = [ivarName substringFromIndex:1];</div><div class="line">        id value = dataDic[ivarName];</div><div class="line">        [model setValue:value forKey:ivarName];</div><div class="line">    &#125;</div><div class="line">    free(ivarsA);</div><div class="line">    return model;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是把字典转成model，先用class_copyIvar获取该model的所有实例变量,然后通过kvc对属性进行赋值。最终返回model。这里有个点需要注意以下几点：  </p>
<ol>
<li>你的model的属性名称要和服务端返回的数据一致，比如你的model有个属性叫做name，那么你服务端返回的数据字典里面的对应属性也要叫做name，因为这个方法是根据属性从字典里面拿数据的。你也可以做一个映射，让自定义的实例变量名称映射到服务端提供的变量名称。</li>
<li>实现里面有个substringFromIndex：操作，其目的就是把使用该方法拿到的实例变量前面的” <em> “去掉。所以你最好使用 @property进行属性声明，并且不要去修改自动生成的实例变量。（@property = getter + setter + </em> ivar，这里的 _ ivar其实就是编译器帮我们生成的实例变量）</li>
</ol>
<p>接下来你可以尝试去获取UILabel的实例变量列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self ivarArray:[UILabel class]]</div></pre></td></tr></table></figure>
<p>你会发现拿到的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    &quot;_size&quot;,</div><div class="line">    &quot;_highlightedColor&quot;,</div><div class="line">    &quot;_numberOfLines&quot;,</div><div class="line">    &quot;_measuredNumberOfLines&quot;,</div><div class="line">    &quot;_baselineReferenceBounds&quot;,</div><div class="line">    &quot;_lastLineBaseline&quot;,</div><div class="line">    &quot;_previousBaselineOffsetFromBottom&quot;,</div><div class="line">    &quot;_firstLineBaseline&quot;,</div><div class="line">    &quot;_previousFirstLineBaseline&quot;,</div><div class="line">    &quot;_minimumScaleFactor&quot;,</div><div class="line">    &quot;_content&quot;,</div><div class="line">    &quot;_synthesizedAttributedText&quot;,</div><div class="line">    &quot;_defaultAttributes&quot;,</div><div class="line">    &quot;_fallbackColorsForUserInterfaceStyle&quot;,</div><div class="line">    &quot;_minimumFontSize&quot;,</div><div class="line">    &quot;_lineSpacing&quot;,</div><div class="line">    &quot;_layout&quot;,</div><div class="line">    &quot;_scaledMetrics&quot;,</div><div class="line">    &quot;_cachedIntrinsicContentSize&quot;,</div><div class="line">    &quot;_contentsFormat&quot;,</div><div class="line">    &quot;_cuiCatalog&quot;,</div><div class="line">    &quot;_cuiStyleEffectConfiguration&quot;,</div><div class="line">    &quot;_textLabelFlags&quot;,</div><div class="line">    &quot;_adjustsFontForContentSizeCategory&quot;,</div><div class="line">    &quot;__textColorFollowsTintColor&quot;,</div><div class="line">    &quot;_preferredMaxLayoutWidth&quot;,</div><div class="line">    &quot;_multilineContextWidth&quot;,</div><div class="line">    &quot;__visualStyle&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是跳转到UILabel.h，你会发现里面有好多的属性不包含在我们根据该方法得出的属性数组里面，而且使用该方法得到的属性在UILabel.h里面并没有。这个是什么原因呢？<br>先看一下好多UILabel里面的属性没有在数组里面打印问题：猜想应该是在UILabel.m里面使用了@dynamic。导致没有自动生成getter、setter和ivar，所以没有在数组里面包含。</p>
<blockquote>
<p>@synthsize：如果没有手动实现setter/getter方法那么会自动生成，自动生成_var变量。如果不写，默认生成getter/setter和_var。你也可以使用该关键字自己设置自动变量的名称。<br>@dynamic告诉编译器：属性的setter/getter需要用户自己实现，不自动生成，而且也不会产生_var变量。</p>
</blockquote>
<p>也就是说在UILabel里面虽然有个text的属性，也许在UILabel.m里面已经包含：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic text;</div></pre></td></tr></table></figure>
<p>这样的话在实现里面没有产生实例变量，只是手动实现了getter和setter，所以就不会显示text属性在刚才得到的数组里面了。<br>至于数组中有UILabel.h里面没有的变量，这个就好理解了，有可能在UILabel.m里面添加了一些实例变量或者在运行时添加了这些实例变量。   </p>
<p>除此方法之外，你还可以使用class_copyPropertyList方法，这个是拿到的所有用 @property声明的属性,包括在.m里面添加的属性（所以打印出来的可能要比真实在.h里面看到的多），具体实现和上面的获取方法类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)propertyArr:(Class)cls &#123;</div><div class="line">    unsigned count = 0;</div><div class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;count);</div><div class="line">    if (count == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:count];</div><div class="line">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)] ;</div><div class="line">        [arr addObject:propertyName];</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的copyPropertyList方法解释如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/class_copyIvarList/class_copyPropertyList.png" alt="class_copyPropertyList"><br>记得使用过后也要调用free去释放数组。（PS：在源代码中暂未找到objc_property结构体的说明）因此，你可以通过使用该方法来实现字典或者json字符串转model操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)zg_modelFromDic:(NSDictionary *)dataDic &#123;</div><div class="line">    id model = [[self alloc] init];</div><div class="line">    unsigned int count = 0;</div><div class="line">    </div><div class="line">    objc_property_t *properties = class_copyPropertyList([self class], &amp;count);</div><div class="line">    if (count == 0) &#123;</div><div class="line">        return model;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0;i &lt; count; i++) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)];</div><div class="line">        id value = dataDic[propertyName];</div><div class="line">        [model setValue:value forKey:propertyName];</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    return model;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种方式均可实现model转换操作。<br>以上便是由class_copyIvarList所引发的思考。</p>
<p>转载请标明来源：<a href="http://supermokey.com/2018/01/02/class-copyIvarList/" target="_blank" rel="noopener">http://supermokey.com/2018/01/02/class-copyIvarList/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在runtime.h中，你可以通过其中的class_copyIvarList方法来获取实例变量。具体的实现如下（记得导入头文件&lt;objc runtime.h=&quot;&quot;&gt;）：&lt;/objc&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="class_copyIvarList" scheme="http://yoursite.com/tags/class-copyIvarList/"/>
    
  </entry>
  
  <entry>
    <title>老生常谈之Block</title>
    <link href="http://yoursite.com/2017/12/28/deep-block/"/>
    <id>http://yoursite.com/2017/12/28/deep-block/</id>
    <published>2017-12-28T08:17:40.000Z</published>
    <updated>2017-12-28T08:23:31.505Z</updated>
    
    <content type="html"><![CDATA[<p>前面有一篇介绍<a href="http://www.cnblogs.com/zhanggui/p/4656440.html" target="_blank" rel="noopener">Block的博客</a>，主要介绍了Block的简单使用技巧。这篇博客主要更加深入地了解一下Block。包括：Block的实现、__Block的原理以及Block的存储域三方面。</p>
<h4 id="Block的实现"><a href="#Block的实现" class="headerlink" title="Block的实现"></a>Block的实现</h4><p>首先我们使用Xcode创建一个Project,点击File–&gt;New–&gt;Project，选择macOS中Application的Command Line Tool，然后设置Project Name即可。你好发现这个工程值包含了一个main.m文件，然后我们做如下更改（更改后的代码如下）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    printf(&quot;Hello World&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个是我们最常见的C代码，导入stdio.h，然后打印出来Hello World。接下来我们写一个最简单的block，没有返回值，没有传入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    </div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        printf(&quot;Hello Worldddd&quot;);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印出来的结果相当于调用了blk输出的结果。接下来我们在item中跳转到main.m所在文件夹然后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure>
<p>你会发现在当前文件夹下生成了一个.cpp文件，它是经过clang编译器编译之后的文件，打开之后里面大概有5百多行，其实我们看下面的这些代码就足够了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">#ifndef BLOCK_IMPL</div><div class="line">#define BLOCK_IMPL</div><div class="line">struct __block_impl &#123;</div><div class="line">    void *isa;</div><div class="line">    int Flags;</div><div class="line">    int Reserved;</div><div class="line">    void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        printf(&quot;Hello Worldddd&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中包含三个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0、__block_impl、__main_block_desc_0</div></pre></td></tr></table></figure>
<p>和两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__main_block_func_0、main</div></pre></td></tr></table></figure>
<p>main就是我们写的main函数。<br>至此，你能知道的就是：Block看上去很特别，其实就是作为及其普通的C语言源代码来处理的。编译器会把Block的源代码转换成一般的C语言编译器能处理的源代码，并作为极为普通的C语言源代码被编译。<br>接下来对编译的内容来一个分解，首先是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^&#123;printf(&quot;Hello Worldddd&quot;)&#125;;</div></pre></td></tr></table></figure>
<p>变换后的源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        printf(&quot;Hello Worldddd&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是现在变成了一个静态方法，其命名方式为：Block所属的函数名(main)和该Block语法在函数出现的顺序值(0)来给经过clang变换的函数命名。该方法的参数相当于我们在OC里面的指向自身的self。我们看一下该参数的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 *__cself</div></pre></td></tr></table></figure>
<p>你会发现它其实是一个结构体，该结构体的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该结构体中你会发现里面有一个构造函数，你忽略构造函数，会发现该结构体就很简单了，只是包含了impl和 Desc两个属性变量。其中impl也是一个结构体，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">    void *isa;</div><div class="line">    int Flags;</div><div class="line">    int Reserved;</div><div class="line">    void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从属性变量的名字我们可以猜测出该结构体各个属性的含义：   </p>
<ol>
<li>isa：isa指针，指向父类的指针。  </li>
<li>Flags：一个标记  </li>
<li>Reserved：预留区域，用于以后的使用。  </li>
<li>FuncPtr：这个很重要，是一个函数指针。后面会详细说明它的作用。</li>
</ol>
<p>第二个变量是Desc，也是一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>这个结构体就比较简单了，一个预留位，一个是指代该Block大小的属性，后面又包含了一个该实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>预留位为0，大小为传入结构体的大小。接下来就是很重要的构造函数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">   impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">   impl.Flags = flags;</div><div class="line">   impl.FuncPtr = fp;</div><div class="line">   Desc = desc;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>其中的&amp;_NSConcreteStackBlock用于初始化impl的isa指针；flags为0；FuncPtr是构造函数传过来的fp函数指针；Desc为一个block的描述。到这里三个结构体和一个函数就介绍完了。接下来看一下main函数里面上述构造函数是如何调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div></pre></td></tr></table></figure>
<p>感觉好复杂，我们先做一个转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 tmpeImpl = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)</div><div class="line"></div><div class="line">struct __main_block_impl_0 *blk = &amp;tmpeImpl;</div></pre></td></tr></table></figure>
<p>也就是说把结构体的实例的指针赋值给blk。接下来再看一下构造函数的的初始化，其实赋值就变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">impl.isa = &amp;_NSConcreteStackBLock;</div><div class="line">impl.Flags = 0;</div><div class="line">impl.FuncPtr = __main_block_func_0;</div><div class="line">Desc = &amp;__main_block_desc_0_DATA;</div></pre></td></tr></table></figure>
<p>现在在看一下调用block的那句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blk();</div></pre></td></tr></table></figure>
<p>转换成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div></pre></td></tr></table></figure>
<p><strong>这个转换不是太明白，但是知道他的作用就是把blk当做参数传进去，调用的FuncPtr所指向的函数，也就是_<em> block </em> block <em> func </em> 0。</strong>   </p>
<p>到这里就大体了解了Block的实现，其实就是C的几个结构体和方法，经过赋值和调用，进而实现了Block。<br>另外Block其实实质上也是OC的对象。</p>
<h4 id="Block的原理"><a href="#Block的原理" class="headerlink" title="__Block的原理"></a>__Block的原理</h4><p>先看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int i = 3;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        printf(&quot;Hello World,%d&quot;,i);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang编译后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int i;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int i = __cself-&gt;i; // bound by copy</div><div class="line"></div><div class="line">        printf(&quot;Hello World,%d&quot;,i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int i = 3;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是在main函数调用的时候把i传到了构造函数里，然后通过i( <em> i)对结构体的属性变量i赋值，i变量现在已经成为了结构体的一个树形变量。在构造函数执行时把i赋值。在 __ main </em> block<em>func </em> 0里面通过 __ cself调用，这个变量实际是在声明block时，被复制到了结构体变量i，因此不会影响变量i的值。当我们尝试在Block中去修改时，你会得到如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Variable is not assignable(missing __block type specifier)</div></pre></td></tr></table></figure>
<p>提示我们加上__block,接下来我们将源代码做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    __block int i = 3;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        i = i + 3;</div><div class="line">        printf(&quot;Hello World,%d&quot;,i);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下你会发现你成功对i的值进行了修改！用clang进行编译，结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line"></div><div class="line">        (i-&gt;__forwarding-&gt;i) = (i-&gt;__forwarding-&gt;i) + 3;</div><div class="line">        printf(&quot;Hello World,%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">    &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 3&#125;;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现多了一个<strong> Block _ byref <em>i </em> 0的结构体，然后多了两个copy和dispose函数。<br>看一下main函数里面的i，此时也不再是一个简单的基本类型int，而是一个初始化的 </strong> Block <em> byref </em> i <em> 0的结构体，该结构体有个属性变量为i，然后把3赋值给了那个属性变量。该结构体还有一个指向自己的指针 <strong> forwarding，它被赋值为i的地址。<br>现在 </strong> main </em> block <em> func </em> 0在实现中使用了指向该变量的指针，所以达到了修改外部变量的作用。</p>
<h4 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h4><p>Block的存储域有以下几种： </p>
<ol>
<li>_ NSConcreteStackBlock,该类的对象Block设置在栈上</li>
<li>_ NSConcreteGlobalBlock,该类的Block设置在程序的数据区(.data)域中。</li>
<li>_ NSConcreteMallocBlcok,该类的Block设置在堆上<br>下面这张图展示了Block的存储域:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/block_save_area.jpeg" alt="Block的存储域"></p>
<p>我们前面看到的都是在Stack的Block，但是你可以在OC工程中打印一下你声明的block的isa，你会发现它其实是Malloc的block，也就是在堆上的block。如图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/malloc_block.png" alt="堆上的block"><br>还有一种情况是Global的block：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/global_block.png" alt="global的block"><br>在ARC中，只有NSConcreteGlobalBlock和NSConcreteMallockBlock两种类型的block。因为我们最简单的block在工程中打印出来的都是MallocBlock。也许是因为苹果把对象都放到了堆管理，而Block也是对象，所以也放到了堆上。</p>
<p>此时我们也许会有个疑问：Block超出了变量作用域为什么还能存在呢？<br>对于Global的Block，变量作用域之外也可以通过指针安全使用，但是设置在栈上的就比较尴尬了，作用域结束后，Block也会 被废弃。为了使Block超出变量作用域还可以存在，Block提供了将Block和 __ block变量从栈上复制到堆上的方法来解决这个问题。这样就算栈上的废弃，堆上的Block还可以继续存在。</p>
<p>看一下对Block进行复制，结果如何：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/block_copy.jpeg" alt="Block进行copy操作"><br>如果对Block进行了copy操作，<strong> block的变量也会受到影响，当 </strong> block的变量配置在栈上，复制之后它将从栈复制到堆上并被Blcok持有，如果是堆上的 <strong> block变量，Blcok复制之后该变量被Block持有。<br>如果两个block（block1,block2）同时都是用 </strong> block变量，如果block1被复制到了堆上，那么 <strong> block变量也会在block1复制到堆的同时复制到堆上，当block2再是用到 </strong> block变量的时候，只是增加堆上 <strong> block变量的引用计数，不会再次复制。如果堆上的block1和block2被废弃了，那么它所是用的 </strong> block变量也就被释放了（如果block1被废弃，而block2没有被废弃，那么 <strong> block变量的引用计数-1，直到最后使用 </strong> block变量的block被废弃的同时，堆上的 <strong> block也会被释放）。<br>理解了上面刚才说的复制之后，现在回过来思考另一个问题： </strong> block的时候转换的结构体中的 <strong> forwarding指针有什么作用呢？（下面代码中的 </strong> forwarding）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实是这样的：栈上的 <strong> block变量用结构体实例在 </strong> block变量从栈复制到堆上的时候，会将成员变量 <strong> forwarding的值替换为复制目标堆上的 </strong> block变量用结构体实例的地址。通过该操作之后，无论是在Block语法中、Block语法外使用 <strong> block变量，还是 </strong> block变量配置在栈上或者堆上，都可以顺利地访问同一个 __ block变量。</p>
<p>以上便是对block的进一步介绍，主要参考了《Objective-C高级编程 iOS与OS X多线程和内存管理》一书。</p>
<p>转赞请标明来源：<a href="http://supermokey.com/2017/12/28/deep-block/" target="_blank" rel="noopener">http://supermokey.com/2017/12/28/deep-block/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面有一篇介绍&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/4656440.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Block的博客&lt;/a&gt;，主要介绍了Block的简单使用技巧。这篇博客主要更加深入地
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出了解frame和bounds</title>
    <link href="http://yoursite.com/2017/12/20/bounds-frame/"/>
    <id>http://yoursite.com/2017/12/20/bounds-frame/</id>
    <published>2017-12-20T14:04:36.000Z</published>
    <updated>2017-12-20T14:35:50.114Z</updated>
    
    <content type="html"><![CDATA[<h5 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h5><p>frame的官方解释如下：</p>
<blockquote>
<p>The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.</p>
<p>This rectangle defines the size and position of the view in its superview’s coordinate system. Use this rectangle during layout operations to set the size and position the view. Setting this property changes the point specified by the center property and changes the size in the bounds rectangle accordingly. The coordinates of the frame rectangle are always specified in points.</p>
</blockquote>
<p>它定义了一个view相对于父视图坐标系的位置和大小，它会影响center属性和bounds属性的size。<br>先看一下它究竟是什么？<br>它是一个CGRect类型,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">    CGPoint origin;</div><div class="line">    CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CG_BOXABLE CGRect CGRect;</div><div class="line"></div><div class="line">struct CGPoint &#123;</div><div class="line">    CGFloat x;</div><div class="line">    CGFloat y;</div><div class="line">&#125;;</div><div class="line">typedef struct CG_BOXABLE CGPoint CGPoint;</div><div class="line"></div><div class="line">/* Sizes. */</div><div class="line"></div><div class="line">struct CGSize &#123;</div><div class="line">    CGFloat width;</div><div class="line">    CGFloat height;</div><div class="line">&#125;;</div><div class="line">typedef struct CG_BOXABLE CGSize CGSize;</div></pre></td></tr></table></figure>
<p>其中的origin就是该view的位置，它是一个CGPoint类型，也是一个结构体，包含了我们熟知的常用二维坐标系的x、y。根据x、y可以在坐标系里面唯一确定一个点。如下图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/frame.jpeg" alt="frame"></p>
<p>这个坐标系和我们平时接触的还不太一样，它是向右向下为正方向。所以对于window来说，其原点是左上角，比如现在的头像的起始坐标就是（200，40）。按照原来常规的坐标系来说，应该是（200，-40）。<br>在设置一个CGRect的时候，用到的方法是CGRectMake,其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CG_INLINE CGRect</div><div class="line">CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)</div><div class="line">&#123;</div><div class="line">  CGRect rect;</div><div class="line">  rect.origin.x = x; rect.origin.y = y;</div><div class="line">  rect.size.width = width; rect.size.height = height;</div><div class="line">  return rect;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是自己在实现部分创建了一个rect，然后逐个赋值。<br>关于frame，这里要注意的一点就是：frame是相对于父视图的坐标系来定位的。如果你这样设置frame:(0,0,100,200),也就是在父视图左上角添加了一个宽100，高200的子视图（前提是没有改变父视图的bounds，接下来会有介绍bounds）。</p>
<h5 id="bounds"><a href="#bounds" class="headerlink" title="bounds"></a>bounds</h5><blockquote>
<p>The bounds rectangle, which describes the view’s location and size in its own coordinate system.</p>
<p>The default bounds origin is (0,0) and the size is the same as the size of the rectangle in the frame property. Changing the size portion of this rectangle grows or shrinks the view relative to its center point. Changing the size also changes the size of the rectangle in the frame property to match. The coordinates of the bounds rectangle are always specified in points.</p>
<p>Changing the bounds rectangle automatically redisplays the view without calling its drawRect: method. If you want UIKit to call the drawRect: method, set the contentMode property to UIViewContentModeRedraw.<br>Changes to this property can be animated.</p>
</blockquote>
<p>它也是描述的是视图的位置和大小，只不过是在自己的坐标系上。也就是说它描述的是当前视图相对于自身坐标系的位置和大小。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">   </div><div class="line">    CGRect rect  = self.view.frame;</div><div class="line">    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];</div><div class="line">    self.parentView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:_parentView];</div><div class="line">    NSLog(@&quot;frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">frame:&#123;&#123;60, 80&#125;, &#123;200, 408&#125;&#125;</div><div class="line">bounds:&#123;&#123;0, 0&#125;, &#123;200, 408&#125;&#125;</div><div class="line">center:&#123;160, 284&#125;</div></pre></td></tr></table></figure>
<p>由此可见，如果我们没有去更改bounds的值，它默认的位置坐标点是(0,0)。</p>
<h5 id="center"><a href="#center" class="headerlink" title="center"></a>center</h5><blockquote>
<p>The center point of the view’s frame rectangle.</p>
<p>The center point is specified in points in the coordinate system of its superview. Setting this property updates the origin of the rectangle in the frame property appropriately.</p>
<p>Use this property, instead of the frame property, when you want to change the position of a view. The center point is always valid, even when scaling or rotation factors are applied to the view’s transform. </p>
<p>Changes to this property can be animated.</p>
</blockquote>
<p>center是view的中点。该属性是想归于父类的坐标系确定的。从bounds小节里面的例子可以看到center的值，其计算方法为：   </p>
<p><strong>center.x = frame.origin.x + frame.size.width/2</strong><br><strong>center.y = frame.origin.y + frame.size.height/2</strong>     </p>
<h5 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h5><blockquote>
<p>Specifies the transform applied to the view, relative to the center of its bounds.<br>Use this property to scale or rotate the view’s frame rectangle within its superview’s coordinate system. (To change the position of the view, modify the center property instead.) The default value of this property is CGAffineTransformIdentity.</p>
<p>Transformations occur relative to the view’s anchor point. By default, the anchor point is equal to the center point of the frame rectangle. To change the anchor point, modify the anchorPoint property of the view’s underlying CALayer object.</p>
<p>Changes to this property can be animated.</p>
<p>In iOS 8.0 and later, the transform property does not affect Auto Layout. Auto layout calculates a view’s alignment rectangle based on its untransformed frame.</p>
</blockquote>
<p>它用于指定视图的变换。使用这个属性可以放大或者旋转视图，它的frame会因此改变，是以中心点为变换的。看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">   </div><div class="line">    CGRect rect  = self.view.frame;</div><div class="line">    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];</div><div class="line">    self.parentView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:_parentView];</div><div class="line">    NSLog(@&quot;frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line">    </div><div class="line">    self.parentView.transform = CGAffineTransformMakeRotation(60);</div><div class="line">   </div><div class="line">    NSLog(@&quot;after change transform,frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;after change transform,bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;after change transform,center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看输出的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">frame:&#123;&#123;60, 80&#125;, &#123;200, 408&#125;&#125;</div><div class="line">bounds:&#123;&#123;0, 0&#125;, &#123;200, 408&#125;&#125;</div><div class="line">center:&#123;160, 284&#125;</div><div class="line">after change transform,frame:&#123;&#123;2.5773352536321568, 59.226689885086444&#125;, &#123;314.84532949273569, 449.54662022982711&#125;&#125;</div><div class="line">after change transform,bounds:&#123;&#123;0, 0&#125;, &#123;200, 408&#125;&#125;</div><div class="line">after change transform,center:&#123;160, 284&#125;</div></pre></td></tr></table></figure>
<p>如图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/transform.jpeg" alt="transform"><br>可以看出，当我们对图像通过旋转,旋转后的图片的frame已经变成了{(2.5773352536321568, 59.226689885086444), (314.84532949273569, 449.54662022982711)},此时的起始位置为图上旋转后标的（2.58,59.2）,大小也变成了双箭头黑线标注的大小。<br>因此得出结论：进行了transform变换，其frame改变了，但是其bounds和center并没有修改。此时bounds的size和frame的size已经没有关系了。当没有进行任何transform时，frame的size总是和bounds相等。</p>
<p>以上便是对frame、bounds、center和transform做了一个简单的介绍。</p>
<h5 id="bounds的使用"><a href="#bounds的使用" class="headerlink" title="bounds的使用"></a>bounds的使用</h5><p>接下来看一个例子（例子A）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">   </div><div class="line">    CGRect rect  = self.view.frame;</div><div class="line">    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];</div><div class="line">    self.parentView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:_parentView];</div><div class="line">    NSLog(@&quot;frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line"> </div><div class="line">    self.parentView.bounds = CGRectMake(-40, -40, self.parentView.frame.size.width, self.parentView.frame.size.height);</div><div class="line">    NSLog(@&quot;parent change bound ,frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;parent change bound ,bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;parent change bound ,center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line"></div><div class="line">    self.childView = [[ChildView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];</div><div class="line">    self.childView.backgroundColor = [UIColor yellowColor];</div><div class="line">    [self.parentView addSubview:_childView];</div><div class="line">   </div><div class="line">    NSLog(@&quot;childView frame:%@&quot;,NSStringFromCGRect(self.childView.frame));</div><div class="line">    NSLog(@&quot;childView ounds:%@&quot;,NSStringFromCGRect(self.childView.bounds));</div><div class="line">    NSLog(@&quot;childView center:%@&quot;,NSStringFromCGPoint(self.childView.center));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里在parentView上添加了一个childView,然后对parentView的bounds进行修改和不修改进行了测试，结果如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/changebounds.jpeg" alt="change bounds"><br>你会发现当修改了parentView的bounds之后，发现childView缺向右向下做了偏移。这里设置parentView的bounds的origin为（-40,-40）为何会发生这种情况呢？接下来先看一下下面这张图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/coordient_system.jpeg" alt="坐标系"></p>
<p>+代表正方向，-代表负方向。</p>
<p>如果此时我们没有改变图中O的坐标，那么此时A的坐标是(20,20)，如果我们更改了O的坐标为（-20,-20），那么原来A点的坐标就成了A’（0,0）,但是A坐标是不变的，所以它会到黑色A处。所以你改变了原点坐标为负之后，A点会移动到黑色A。相反如果你设置了坐标原点为（20,20），那么A点就会和坐标原点重合。<br>这就是为什么childView会向右向下移动的原因。<br>接下来再做如下操作（例子B）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">   </div><div class="line">    CGRect rect  = self.view.frame;</div><div class="line">    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];</div><div class="line">    self.parentView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:_parentView];</div><div class="line">     </div><div class="line">    NSLog(@&quot;parent change bound ,frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">    NSLog(@&quot;parent change bound ,bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">    NSLog(@&quot;parent change bound ,center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line"></div><div class="line">    self.childView = [[ChildView alloc] initWithFrame:CGRectMake(self.parentView.frame.origin.x, self.parentView.frame.origin.y+self.parentView.frame.size.height-200, 100, 100)];</div><div class="line">    self.childView.backgroundColor = [UIColor yellowColor];</div><div class="line">    [self.parentView addSubview:_childView];</div><div class="line">   </div><div class="line">    </div><div class="line">    NSLog(@&quot;childView frame:%@&quot;,NSStringFromCGRect(self.childView.frame));</div><div class="line">    NSLog(@&quot;childView ounds:%@&quot;,NSStringFromCGRect(self.childView.bounds));</div><div class="line">    NSLog(@&quot;childView center:%@&quot;,NSStringFromCGPoint(self.childView.center));</div><div class="line">    NSLog(@&quot;\n--------\n&quot;);</div><div class="line">    CGRect parentBounds = self.parentView.bounds;</div><div class="line">    [UIView animateWithDuration:2 animations:^&#123;</div><div class="line">        </div><div class="line">        self.parentView.bounds = CGRectMake(parentBounds.origin.x, 400, parentBounds.size.width, parentBounds.size.height);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        NSLog(@&quot;anim finished,parentView frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));</div><div class="line">        NSLog(@&quot;anim finished,parentView ounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));</div><div class="line">        NSLog(@&quot;anim finished,parentView center:%@&quot;,NSStringFromCGPoint(self.parentView.center));</div><div class="line">        NSLog(@&quot;anim finished,childView frame:%@&quot;,NSStringFromCGRect(self.childView.frame));</div><div class="line">        NSLog(@&quot;anim finished,childView bounds:%@&quot;,NSStringFromCGRect(self.childView.bounds));</div><div class="line">        NSLog(@&quot;anim finished,childView center:%@&quot;,NSStringFromCGPoint(self.childView.center));</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">parent change bound ,frame:&#123;&#123;60, 80&#125;, &#123;200, 408&#125;&#125;</div><div class="line">parent change bound ,bounds:&#123;&#123;0, 0&#125;, &#123;200, 408&#125;&#125;</div><div class="line">parent change bound ,center:&#123;160, 284&#125;</div><div class="line">childView frame:&#123;&#123;60, 288&#125;, &#123;100, 100&#125;&#125;</div><div class="line">childView ounds:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;</div><div class="line">childView center:&#123;110, 338&#125;</div><div class="line">--------</div><div class="line">anim finished,parentView frame:&#123;&#123;60, 80&#125;, &#123;200, 408&#125;&#125;</div><div class="line">anim finished,parentView ounds:&#123;&#123;0, 400&#125;, &#123;200, 408&#125;&#125;</div><div class="line">anim finished,parentView center:&#123;160, 284&#125;</div><div class="line">anim finished,childView frame:&#123;&#123;60, 288&#125;, &#123;100, 100&#125;&#125;</div><div class="line">anim finished,childView bounds:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;</div><div class="line">anim finished,childView center:&#123;110, 338&#125;</div></pre></td></tr></table></figure>
<p>运行效果是childView向上移动，然后停止。结果前后对比图如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/animationbounds.jpeg" alt="animation bounds"><br>直观来看，按说childView的frame改变了，但是从console输出的结果来看，childView的frame/bounds/center都没有改变，但是直观来看其位置却改变了。再看一下parentView,只有bounds改变了，frame和center却没变，从直观来看parentView没有任何更改。所以很有可能是parentView的bounds修改引起了childView的位置更改。这是为什么呢？这里先不说明为什么，再看一下最常用的UIScrollView:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.scrollView = [[ZGUIScrolLView alloc] initWithFrame:self.view.frame];</div><div class="line">    self.scrollView.delegate = self;</div><div class="line">    [self.view addSubview:_scrollView];</div><div class="line">    NSLog(@&quot;scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));</div><div class="line">    NSLog(@&quot;scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));</div><div class="line">    NSLog(@&quot;scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));</div><div class="line">    self.scrollView.contentSize = CGSizeMake(800, 800);</div><div class="line">    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(20, 100, 250, 300)];</div><div class="line">    self.parentView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.scrollView addSubview:_parentView];</div><div class="line">    NSLog(@&quot;parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));</div><div class="line">    NSLog(@&quot;parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));</div><div class="line">    NSLog(@&quot;parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</div><div class="line">    NSLog(@&quot;didScroll scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));</div><div class="line">    NSLog(@&quot;didScroll scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));</div><div class="line">    NSLog(@&quot;didScroll scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));</div><div class="line">    NSLog(@&quot;didScroll parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));</div><div class="line">    NSLog(@&quot;didScroll parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));</div><div class="line">    NSLog(@&quot;didScroll parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));</div><div class="line">    printf(&quot;\n-------------------------------------------\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当滚动视图的时候，console输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">scrollview frame:&#123;&#123;0, 0&#125;, &#123;320, 568&#125;&#125;</div><div class="line">scrollview bounds:&#123;&#123;0, 0&#125;, &#123;320, 568&#125;&#125;</div><div class="line">scrollview center:&#123;160, 284&#125;</div><div class="line">parentView frame:&#123;&#123;20, 100&#125;, &#123;250, 300&#125;&#125;</div><div class="line">parentView bounds:&#123;&#123;0, 0&#125;, &#123;250, 300&#125;&#125;</div><div class="line">parentView center:&#123;145, 250&#125;</div><div class="line">didScroll scrollview frame:&#123;&#123;0, 0&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview bounds:&#123;&#123;0, -20&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview center:&#123;160, 284&#125;</div><div class="line">didScroll parentView frame:&#123;&#123;20, 100&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView bounds:&#123;&#123;0, 0&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView center:&#123;145, 250&#125;</div><div class="line">-------------------------------------------</div><div class="line">didScroll scrollview frame:&#123;&#123;0, 0&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview bounds:&#123;&#123;8.5, 31.5&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview center:&#123;160, 284&#125;</div><div class="line">didScroll parentView frame:&#123;&#123;20, 100&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView bounds:&#123;&#123;0, 0&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView center:&#123;145, 250&#125;</div><div class="line">-------------------------------------------</div><div class="line">didScroll scrollview frame:&#123;&#123;0, 0&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview bounds:&#123;&#123;25.5, 162&#125;, &#123;320, 568&#125;&#125;</div><div class="line">didScroll scrollview center:&#123;160, 284&#125;</div><div class="line">didScroll parentView frame:&#123;&#123;20, 100&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView bounds:&#123;&#123;0, 0&#125;, &#123;250, 300&#125;&#125;</div><div class="line">didScroll parentView center:&#123;145, 250&#125;</div></pre></td></tr></table></figure>
<p>根据输出结果可以看到，parentView的center、frame、bounds在滚动过程中都没有作出更改，但是我们看到的它的位置的确改变了。而对于scrollView来说，其frame和center也没有更改，但是bounds更改了。<br>这种现象和上面提到的（例子B）的现象一样，都是对bounds进行了修改。然后子视图从新进行了布局。说道子视图重新布局，让我想到了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)layoutSubviews;</div></pre></td></tr></table></figure>
<p>从字面意思看就是布局某个视图的子视图，那么会不会和这个方法有关呢？因此我在自定义的ZGUIScrollView里面实现了该方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)layoutSubviews &#123;</div><div class="line">    NSLog(@&quot;scrollview&apos;s layoutSubViews called&quot;);</div><div class="line">    [super layoutSubviews];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次滚动界面，发现每次滚动都会调用scrollview的layoutSubViews方法。苹果官方文档介绍：</p>
<blockquote>
<p>Lays out subviews.</p>
<p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>
</blockquote>
<p>它的作用就是布局一个视图上的子视图。确定子视图的大小和位置。如果你想强制布局更新，你不能直接去调用这个方法，而是在下次更新图形之前调用setNeedsLayout方法，如果你要立即更新视图布局，调用layoutIfNeeded方法。</p>
<p>由此可知，<strong>UIScrollView的实现就是通过bounds来实现的。contentOffset是bounds的origin。然后当bounds修改之后，会在layoutSubviews方法里面对子视图进行布局。对子类进行更新</strong>。<br>另外，我们还可以用bounds实现如下效果：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/boundstocell.jpeg" alt="bounds to set cell"><br>图上右侧便是使用了bounds实现的效果。实现方式就是在自定义cell中重写drawReact:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">     self.bounds = CGRectMake(self.bounds.origin.x, self.bounds.origin.y, self.frame.size.width-20, self.frame.size.height - 5);</div><div class="line">    [super drawRect:rect];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实UITableView(它是UIScrollView)的实现也是类似，更改了bounds,来实现滚动加载cell。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对bounds和frame的理解就是这些，其实系统用bounds的地方还是很多的。例如UIScrollView的实现就用到了。有疑问的话可以留言交流。</p>
<p><strong>注：转赞请标明来源：<a href="http://supermokey.com/2017/12/20/bounds-frame/" target="_blank" rel="noopener">张贵的博客</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;frame&quot;&gt;&lt;a href=&quot;#frame&quot; class=&quot;headerlink&quot; title=&quot;frame&quot;&gt;&lt;/a&gt;frame&lt;/h5&gt;&lt;p&gt;frame的官方解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The frame rectangle, whi
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="bounds" scheme="http://yoursite.com/tags/bounds/"/>
    
      <category term="frame" scheme="http://yoursite.com/tags/frame/"/>
    
      <category term="UIScrollView" scheme="http://yoursite.com/tags/UIScrollView/"/>
    
  </entry>
  
  <entry>
    <title>旅游篇--泰国之旅游记</title>
    <link href="http://yoursite.com/2017/12/13/travle-to-tailand/"/>
    <id>http://yoursite.com/2017/12/13/travle-to-tailand/</id>
    <published>2017-12-13T13:17:44.000Z</published>
    <updated>2017-12-13T13:45:39.442Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/thailand_travel/top.jpeg" alt="住宿度假村"></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>寻思着结过婚就应该有个蜜月之旅，要不然总是觉得缺了一点什么。因此打算出国旅游。</p>
<p>由于我的爱人喜欢大海，所以我们当时有两个地方选择：巴厘岛、普吉岛（其他地方暂时没有考虑）。现在想想，幸亏选择了普吉岛，要是去了巴厘岛还要乘坐救援飞机了。</p>
<h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5><p>先说一下我们前期的准备：</p>
<p>1.报团</p>
<p>其实我们之前有考虑自由行的，但是觉得第一次出国，又没有什么经验，还是跟团出去比较靠谱。但是随之而来的就是各种言论：报团旅行就是流水线、报团导游会强迫你买东西，不买的话会恶语讽刺等等。也就纠结了好久。不过总要有第一次，总要去尝试。所以我们最终选择了报团。</p>
<p>接下来就是报哪个团了，是途牛、携程、飞猪、凯撒。。。这就更需要慎重了，我是先将路线进行了对比：包括出发时间、航班、跟团旅行的景点等做了对比，发现大体都差不多。好几个好友都说可以试试凯撒，他们用的都是凯撒。我在网上查了一下，凯撒的口碑还是不错的。其实还有最重要的一点：凯撒把每个团的具体事宜安排的很详细，包括每天的行程、时间安排、吃饭等等。所以最终选择了凯撒。</p>
<p>发现报团最大的一个好处就是：你不用提前做大量的攻略，因为他们已经帮你制定好了路线，你只需要按照路线走即可。当然也有缺点：比如自由活动时间相对较少。</p>
<p>我们报的团是凯撒上面的“珊瑚花园—泰国斯米兰群岛+普吉岛7日缤纷之旅”。下面是我们的出团通知：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/thailand_travel/travel_notice.png" alt="出团通知"></p>
<p>哦，对了，我们报团是每人5399元，一共花费10798元。</p>
<p>2.前期准备</p>
<p><strong>1.护照+签证</strong></p>
<p>首先最重要的当然是护照啦。我们是国庆节提前回的家，然后把护照办了。办理很方便，填写表格、拍照，十分钟就搞定了。</p>
<p>签证我们是直接让凯撒帮助我们代办的，你也可以选择落地签。随团办理的话签证费是250元/人 ，落地签费 2000泰铢，落地签通关费约50元人民币。我们报团之后，把护照+照片直接送到了凯撒实体店，然后到机场集合的时候领队统一将护照发到我们手中。这里注意，照片一定要符合要求，例如泰国的签证照片为白底彩色照片，尺寸为2寸，这个你到专业一点的摄影馆，他们那边会按照要求给你做好符合条件的照片。</p>
<p>签证我们的花费是500元人民币。</p>
<p><strong>2.货币换购</strong></p>
<p>本以为货币换购会很麻烦，谁知道我给工行打了个电话，告诉他们我的位置之后，然后工行给我说了一下我附近的换购网点，并且提供了网点电话，我打电话咨询，银行说让我直接过去，不用预约，现在有泰国铢可以换。因此我拿上工行卡就在住所附近的银行直接换了泰铢。如果你需要换泰铢，最好提前和银行沟通，看看银行是否支持换购，而且一定要提前问一下是否需要预约，因为有的时候银行不一定有所换币种的现金。</p>
<p>当时总共换了28000泰铢（我们回来的时候还剩下16580泰铢，也就是3378元人民币左右），大概是5700元人民币多左右，也就是在泰国换购的货币花了11420泰铢（约2327元）。</p>
<p><strong>3.通讯类准备</strong></p>
<p>到了泰国，由于我的手机没有开通国际漫游，所以我爱人提前在淘宝上买了两张happy卡，8天无限流量，完全满足7天的使用。</p>
<p>另外，还买了两个手机防水套，防止玩水或者坐船的时候手机进水。泰国那边是印度洋的水，而且也是几大洋中最咸的海水，所以一旦手机进水，那就不要妄想修好了，可以直接买新机了。</p>
<p><strong>4.其他携带物品</strong></p>
<p>这里将需要携带的物品都列了出来：</p>
<p>主要：</p>
<p>护照、泰铢、信用卡（国际信用卡，如果有可带上，方便境外消费）。</p>
<p>衣物类：</p>
<p>防晒衣、换洗的夏天衣物、一件外套（防止天气下雨温度变化大）、游泳装备。</p>
<p>洗漱用品：</p>
<p>牙膏牙刷（牙膏超过100ml的需要托运，我们带的超过了100ml，就寄存到了机场，在普及当地又买了一盒牙膏）、洗脸用品、防晒霜（如果质量够好，可以带，要是一般建议在泰国本地买，效果比国内好）。</p>
<p>其他生活用品：</p>
<p>雨伞、护照照片（1张，以防护照丢失）、充电器、充电宝、拖鞋、太阳镜、防水手机套、泰国电话卡、晕船药（如有需要）、晕机药（如有需要）。</p>
<p><strong>简单说几点：</strong></p>
<p> 1.泰国酒店不提供牙膏牙刷，你需要自己携带。</p>
<p> 2.超过100ml的液体需要托运。所以我们牙膏没有选择托运，而是直接寄存到了机场，来的时候又取回。</p>
<p> 3.防晒霜最好在泰国本地购买，因为泰国常年都是夏天，紫外线比较强，国内的并不一定实用。</p>
<p> 4.充电宝只要标识产商清楚，可以随身携带。</p>
<p> 5.换洗的衣服最好带4+套，泰国天气潮湿而且不定时下雨，有的时候洗了并不一定干。</p>
<p> 6.泰国遍地都是711，如果你有需要买日常用品，例如牙膏、防晒霜等，可以在711购买。</p>
<p><strong>5.常识了解</strong></p>
<p> 1.泰国的货币有：20THB、50THB、100THB、500THB、1000THB几类，剩下的就是一些硬币了，有1THB、10THB等（THB为泰国铢的意思）。</p>
<p> 2.泰国的时间比北京时间慢1小时，也就是说如果你现在在泰国，时间是19：00，那么在北京这边就是20：00了。当然了，你出行均以当地时间为准。</p>
<p> 3.泰国是一个小费国家。所以记得备一些小额泰铢。比如帮你搬运行李的小哥和整理房间的大姐，一般小费是20THB。搬运行李的小哥帮你搬到指定位置之后，你可以把钱直接给他。至于整理房间，你可以把钱放到房间里面显眼的地方。记着不要给硬币，泰国硬币一般是给乞丐的。</p>
<h4 id="出团"><a href="#出团" class="headerlink" title="出团"></a>出团</h4><p>我们在约定的时间地点和领队集合，然后领队会带着一起坐飞机去普吉岛。我是第一次坐飞机，其实和火车差不多，购票、验票、安检、上机。机场安检比较严格，所以如果你携带的东西太多，可以选择托运，在领取机票的地方将行李托运即可。</p>
<p>如果你晕机，记得先吃晕机的药物。</p>
<p>我们坐的从北京飞往普及的飞机引擎故障，所以整整延误了3个小时才出发。来的时候比较顺利，没有延迟。</p>
<p>飞机上免费提供餐饮，如有需要，可以找乘务员。我们坐的是泰航，几乎所有乘务员都是泰国人，所以在沟通上，你先可以用中文沟通，如果听不懂再用英文。我所坐的班机上的乘务员都能听懂中文。</p>
<p>如果你的行李托运，到了机场会有领取托运行李的地方，按照指定路标找到之后将自己的行李取走即可。</p>
<p>如果是冬季去普吉岛，你可以在飞机上还穿着冬季的衣服，到了普吉机场找个洗手间将衣服换一下即可。</p>
<p>接下来就是几天的旅行啦，浮潜、深海漫步、骑大象、看人妖表演、SPA等等。玩的不亦乐乎。期间也认识了好多朋友，整个出行还是比较满意的。唯一不太满意的就是吃了，可能是自己吃不习惯。个人觉得泰国的食物是酸、辣、甜的混合。幸亏还有蛋炒饭可以吃。对了，如果你晕船，提前吃点晕船药，防止呕吐。</p>
<p>本来想写一下推荐游玩的地方，但是很尴尬不动泰语，也无法明确指定地点。但是有些地点是知道的：比如博森山庄、斯米兰群岛。这两个地点是很不错的地方（不要问我价格，我也不知道，组团团费都包含了）。</p>
<h4 id="花费情况"><a href="#花费情况" class="headerlink" title="花费情况"></a>花费情况</h4><p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/thailand_travel/coast.png" alt="消费"></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>整个团整体还是很满意的，负责的领队，专业的导游，还有来自不同城市的旅友。如果有机会，期待还能和一个团的这些朋友一起旅行。</p>
<h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p>更多图片可参见我的<a href="http://mp.weixin.qq.com/s/4habrJ2niEy5b0GI8A0PfA" target="_blank" rel="noopener">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/thailand_travel/top.jpeg&quot; alt=&quot;住宿度假村&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="泰国" scheme="http://yoursite.com/tags/%E6%B3%B0%E5%9B%BD/"/>
    
  </entry>
  
  <entry>
    <title>我是如何一步一步实现网页离线缓存的？</title>
    <link href="http://yoursite.com/2017/11/28/web-cache/"/>
    <id>http://yoursite.com/2017/11/28/web-cache/</id>
    <published>2017-11-28T05:19:17.000Z</published>
    <updated>2017-11-28T05:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>一个Hybrid APP，如何做离线缓存策略？也可以简单来说，你的APP只是一个壳，里面真正加载的内容是H5，如果优化加载内容的速度？</p>
<h4 id="先了解一下NSURLProtocol"><a href="#先了解一下NSURLProtocol" class="headerlink" title="先了解一下NSURLProtocol"></a>先了解一下NSURLProtocol</h4><p>从面意思看它是一个协议，但是它其实是一个类，而且继承自NSObject。它的作用是处理特定URL协议的加载。它本身是一个抽象类，提供了使用特性URL方案处理URL的基础结构。你可以自己创建NSURLProtocol的子类，来让自己的应用支持自定义的协议或者URL方案。<br>应用程序永远不需要直接实例化一个NSURLProtocol子类。当一个下载开始的时候，系统创建一个合适的protoco对象来响应URL请求。你要做的就是自己定义一个你自己的protocol，然后在APP启动的时候调用registerClass:，让系统知道你的协议。<br>这里需要注意：你不能在watchOS 2以及更高版本中自定义URL scheme和协议。</p>
<p>为了支持特定的自定义请求，你最好定义NSURLRequest 或者NSMutableURLRequest。让自定义的这些对象来实现请求，这里需要使用NSURLProtocol的propertyForKey:inRequest:和setProperty:forKey:inRequest，然后你可以自定义NSURLResponse类来模拟返回信息。<br>接下来就开始对UIWebView进行离线缓存处理。</p>
<h4 id="UIWebView的离线缓存处理"><a href="#UIWebView的离线缓存处理" class="headerlink" title="UIWebView的离线缓存处理"></a>UIWebView的离线缓存处理</h4><p>首先，我们需要自定义一个NSURLProtocol的子类，并且在AppDelegate.m的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    [NSURLProtocol registerClass:[ZGURLProtocol class]];</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注册。接下来的所有操作就都是在我们自定义的ZGURLProtocol中操作了。先看一下registerClass的作用：<br>尝试注册一个NSURLProtocol的子类，使其对<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">URL Loading System</a>可见。这里的URL Loading System就是一组类和协议，允许你的应用程序访问由URL产生的内容，比如请求、接收内容和Cache等。当URL Load System开始加载一个请求的时候，每个注册的协议类都被依次去调用，以确定是否可以用指定的请求去初始化它。首先被调用的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request;</div></pre></td></tr></table></figure></p>
<p>在该方法里面进行缓存过滤，比如你想只缓存js，那么判断request的path的后缀，如果是js，就返回YES，否则返回NO。<br>如果返回YES，那么就相当于该请求被自定义的URLProtocol来处理，这里不能保证所有的注册的NSURLProtocol都能被处理到。如果你定义了多个NSProtocol子类，这些子类将会以相反的顺序调用。也就是说如果你是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[NSURLProtocol registerClass:[ZGURLProtocol class]];</div><div class="line">[NSURLProtocol registerClass:[ZProtocol class]];</div></pre></td></tr></table></figure></p>
<p>那么最先执行的是ZProtocol，如果参initWithRequest:返回的为YES，则请求由ZProtocol进行处理，且不会再走ZGURLProtocol。如果ZProtocol的initWithRequest:返回的为NO，则请求继续向下传递由其他的NSURLProtocol子类处理。<br>一旦返回YES，那么请求将会由自己写的子类处理，首先会调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</div></pre></td></tr></table></figure></p>
<p>这个是一个抽象的方法，子类必须对其实现。通常情况下，我们一般都是直接返回request，但是这里你也可以直接修改此request，包括header，hosts等。可以对指定request进行重定向操作。<br>在这里，我们只是将现有的request进行返回即可。<br>紧接着，便会开始请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)startLoading;</div></pre></td></tr></table></figure></p>
<p>该方法的作用就是开始请求protocol指定的请求。该方法也是protocol子类必须实现的方法。在这里所做的操作就是：<br>先判断是否有缓存数据，如果有，则自己创建NSURLResponse，然后将缓存数据放入，并进行client的一些操作，然后返回；如果没有缓存数据，则新建一个NSURLConnection，然后发送请求。<br>先说一下有缓存的情况下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (model.data &amp;&amp; model.MIMEType) &#123;</div><div class="line">        NSURLResponse *response = [[NSURLResponse alloc] initWithURL:self.request.URL MIMEType:model.MIMEType expectedContentLength:model.data.length textEncodingName:nil];</div><div class="line">        [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</div><div class="line">        [self.client URLProtocol:self didLoadData:model.data];</div><div class="line">        [self.client URLProtocolDidFinishLoading:self];</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>（model是缓存数据）有缓存的情况下,直接使用缓存的数据和MIME类型，然后构建NSURLResponse，然后通过协议client调用代理方法。这里的client是一个protocol，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@protocol NSURLProtocolClient &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;</div><div class="line"></div><div class="line">- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</div><div class="line"></div><div class="line">- (void)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>该协议提供了NSURLProtocol子类与URL Loading System进行沟通的接口。一个APP一定不要去实现这个协议。有缓存的情况下调用回调方法，然后进行处理。<br>在没有缓存的情况下：<br>实例化一个connection，然后发起请求。在我们收到response的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</div><div class="line">    self.responseData = [[NSMutableData alloc] init];</div><div class="line">    self.responseMIMEType = response.MIMEType;</div><div class="line">    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>紧接着就是接收数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</div><div class="line">    [self.responseData appendData:data];</div><div class="line">    [self.client URLProtocol:self didLoadData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收完数据之后便调用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</div><div class="line">    ZGCacheModel *model = [ZGCacheModel new];</div><div class="line">    model.data = self.responseData;</div><div class="line">    model.MIMEType = self.responseMIMEType;</div><div class="line">    [self setMiType:model.MIMEType withKey:[self.request.URL path]];//userdefault存储MIMEtype</div><div class="line">    </div><div class="line">    </div><div class="line">    [[ZGUIWebViewCache sharedWebViewCache] setCacheWithKey:self.request.URL.absoluteString value:model];</div><div class="line">  </div><div class="line">    [self.client URLProtocolDidFinishLoading:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是结束家在之后的调用，我们需要在这里将请求过来的数据进行缓存。这样我们本地就有了指定URL的返回数据。<br>这里还有一个重要的东西没有介绍，那就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[NSURLProtocol propertyForKey:ZGURLProtocolKey inRequest:request]</div><div class="line">[NSURLProtocol setProperty:@YES forKey:ZGURLProtocolKey inRequest:mutableRequest];</div></pre></td></tr></table></figure></p>
<p>这里的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)setProperty:(id)value forKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;</div></pre></td></tr></table></figure></p>
<p>作用是在指定的请求中设置与特定的键值相关联。防止多次调用一个request。<br>这样，我们就完成了UIWebView的离线缓存。在这里我封装了一个<a href="https://github.com/ScottZg/ZGUIWebViewCache" target="_blank" rel="noopener">ZGUIWebViewCache</a>。感兴趣的可以看一下。</p>
<h4 id="WKWebView的离线缓存处理"><a href="#WKWebView的离线缓存处理" class="headerlink" title="WKWebView的离线缓存处理"></a>WKWebView的离线缓存处理</h4><p>WKWebView离线缓存和UIWebView缓存类似，只不过使用WKWebView除了一开始调用一下NSURLProtocol的canInitWithRequest：方法之后，之后的请求似乎就和NSURLProtocol完全无关了，网上都说WKWebView的请求是在独立的进程里，所以不走NSURLProtocol。这里是通过NSURLProtocol+WKWebView类进行处理的，详情可参见：<a href="https://github.com/ScottZg/ZGWKWebViewCache" target="_blank" rel="noopener">ZGWKWebViewCache</a>。<br>剩下的处理过程就和UIWebView缓存处理类似了。<br>以上便是对网页离线缓存的实现。<br>如有问题，欢迎留言沟通！</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>1.<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="noopener">让 WKWebView 支持 NSURLProtocol</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;一个Hybrid APP，如何做离线缓存策略？也可以简单来说，你的APP只是一个壳，里面真正加载的内容是H5，如果优化加载内容的速度？&lt;/p
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://yoursite.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解消息的传递和转发机制</title>
    <link href="http://yoursite.com/2017/10/25/message-forward/"/>
    <id>http://yoursite.com/2017/10/25/message-forward/</id>
    <published>2017-10-25T10:49:00.000Z</published>
    <updated>2017-10-27T02:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在面试过程中你也许会被问到消息转发机制。这篇文章就是对消息的转发机制进行一个梳理。主要包括什么是消息、静态绑定/动态绑定、消息的传递和消息的转发。接下来开始进入正题。</p>
<h5 id="消息的解释"><a href="#消息的解释" class="headerlink" title="消息的解释"></a>消息的解释</h5><p>在其他语言里面，我们可以用一个类去调用某个方法，在OC里面，这个方法就是消息。某个类调用一个方法就是向这个类发送一条消息。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">People *zhangSan = [[People alloc] init];</div><div class="line">People *lisi = [[People alloc] init];</div><div class="line">[zhangSan beFriendWith:lisi];</div></pre></td></tr></table></figure></p>
<p>我们有个People的类，zhangSan这个实例发送了一条beFriendWith:的消息。你也许还看过这种调用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[zhangSan performSelector:@selector(beFriendWith:) withObject:lisi];</div></pre></td></tr></table></figure></p>
<p>其目的和上面的一样，都是向zhangSan发送了一条beFriendWith:的消息，传人的参数都是lisi。<br>这里简单介绍一下SEL和IMP：</p>
<blockquote>
<p>SEL:类成员方法的指针，但和C的函数指针还不一样，函数指针直接保存了方法的地址，但是SEL只是方法编号。<br>IMP:函数指针，保存了方法地址。</p>
</blockquote>
<p>我们叫@selector(beFriendWith:)为消息的选择子或者选择器。(A selector identifying the message to send)</p>
<h5 id="静态绑定-动态绑定"><a href="#静态绑定-动态绑定" class="headerlink" title="静态绑定/动态绑定"></a>静态绑定/动态绑定</h5><p>所谓静态绑定，就是在编译期就能决定运行时所调用的函数，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,world!\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodBye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye,world!\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        printGoodBye();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所谓动态绑定，就是在运行期才能确定调用函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,world!\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodBye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye,world!\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> (*fnc)(<span class="keyword">void</span>);</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        fnc = printGoodBye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在OC中，对象发送消息，就会使用动态绑定机制来决定需要调用的方法。其实底层都是C语言实现的函数，当对象收到消息后，究竟调用那个方法完全决定于运行期，甚至你也可以直接在运行时改变方法，这些特性都使OC成为一门动态语言。</p>
<h5 id="消息的传递"><a href="#消息的传递" class="headerlink" title="消息的传递"></a>消息的传递</h5><p>先看一下一条简单的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure></p>
<p>其中：<br>someObject叫做接收者(receiver)。<br>messageName叫做选择器(selector)<br>选择器和参数合起来成为消息(message)<br>当编译器看到这条消息，就会转换成一条标准的C函数：objc_msgSend,此时会变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</div></pre></td></tr></table></figure></p>
<p>objc_msgSend可以在objc里面的message.h中看到:<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/messageforward/objc_msgSend.png" alt="objc_msgSend"><br>根据官方注释可以看到：</p>
<blockquote>
<p>When it encounters a method call, the compiler generates a call to one of the functions objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, or objc_msgSendSuper_stret. Messages sent to an object’s superclass (using the super keyword) are sent using objc_msgSendSuper; other messages are sent using objc_msgSend. Methods that have data structures as return values are sent using objc_msgSendSuper_stret and objc_msgSend_stret.</p>
</blockquote>
<p>它的作用是向一个实例类发送一个带有简单返回值的message。是一个参数个数不定的函数。当遇到一个方法调用，编译器会生成一个objc_msgSend的调用，有：objc_msgSend_stret、objc_msgSendSuper或者是objc_msgSendSuper_stret。发送给父类的message会使用objc_msgSendSuper，其他的消息会使用objc_msgSend。如果方法的返回值是一个结构体(structures)，那么就会使用objc_msgSendSuper_stret或者objc_msgSend_stret。<br>第一个参数是：指向接收该消息的类的实例的指针<br>第二个参数是：要处理的消息的selector。<br>其他的就是要传入的参数。<br>这样消息派发系统就在接收者所属类中查找器方法列表，如果找到和选择器名称相符的方法就跳转其实现代码，如果找不到，就再其父类找，等找到合适的方法在跳转到实现代码。这里跳转到实现代码这一操作利用了<a href="http://www.cnblogs.com/zhanggui/p/7722541.html" target="_blank" rel="noopener">尾递归优化</a>。<br>如果该消息无法被该类或者其父类解读，就会开始进行消息转发。</p>
<h5 id="理解消息转发机制-message-forwarding"><a href="#理解消息转发机制-message-forwarding" class="headerlink" title="理解消息转发机制(message forwarding)"></a>理解消息转发机制(message forwarding)</h5><h6 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h6><p>不要把消息转发机制想象得很难，其实看过下面的你就会发现，没有那么难。<br>我们有的时候会遇到这样的crash：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/messageforward/crash.png" alt="crash"><br>我们都知道crash的原因是People没有gotoschool这个方法，但是你调用了该方法，所以会产生NSInvalidArgumentException，reason：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[People gotoschool]: unrecognized selector sent to instance 0x1d4201780&apos;</div></pre></td></tr></table></figure></p>
<p>接下来让我们看看从发送消息到此crash的过程。前面消息的传递没有成功找到实现，所以会走到消息转发里面，我先在People类里面实现了这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void gotoSchool(id self,SEL _cmd,id value) &#123;</div><div class="line">    printf(&quot;go to school&quot;);</div><div class="line">&#125;</div><div class="line">//对象在收到无法解读的消息后，首先将调用所属类的该方法。</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSString *selectorString = NSStringFromSelector(sel);</div><div class="line">    if ([selectorString isEqualToString:@&quot;gotoschool&quot;]) &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)gotoSchool, &quot;@@:&quot;);</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再次运行程序，你会发现没有crash了，而且顺利打印出来”go to school”。<br>这个是什么个情况呢？先看看这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div></pre></td></tr></table></figure></p>
<p>这个方法是objc里面NSObject.h里面的方法。从字面理解就是处理实例方法(处理类方法)。下面左边图是对其的介绍：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/messageforward/resolveInstanceMethod.png" alt="resolveInstanceMethod／forwardingTargetForSelector:"><br>它的作用就是给一个实例方法（给定的选择器）动态提供一个实现。注释也提供了一个demo告诉我们如何动态添加实现。<br>也就是说当消息传递无法处理的时候，首先会看一下所属类，是否能动态添加方法，以处理当前未知的选择子。这个过程叫做“动态方法解析”(dynamic method resolution)。<br>这里我在动态方法解析这里动态添加了实现，然后程序就不会崩溃啦。<br>如果是类方法，就调用resolveClassMethod:方法进行操作，和上面的resolveInstanceMethod一样的处理方式。<br>这里还用到了calss_addMethod，后面会单独写篇博客对其介绍。感兴趣的可以先自行查看API。</p>
<h6 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h6><p>当动态方法解析没有实现或者无法处理的时候，就会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</div></pre></td></tr></table></figure></p>
<p>这个方法也是objc里面NSObject.h里面的方法。我对People进行了如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class="line">    if ([selectorString isEqualToString:@&quot;gotoschool&quot;]) &#123;</div><div class="line">        return self.student;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我在People里面添加了一个Student类实例，然后实现了forwardingTargetForSelector：方法。然后运行，奇迹地发现程序也没有崩溃。该方法的作用是（上图也有介绍）：<br>返回一个对未识别消息处理的对象。如果实现了该方法，并且该方法没有返回nil，那么这个返回的对象就会作为新的接收对象，这个未知的消息将会被新对象处理。通过此方案，我们可以用组合来模拟多重继承的某些特性，比如我返回多个类的组合，那么就像继承多个类一样进行处理。在对外调用者来说，好像就是该对象亲自处理的这些消息。</p>
<h6 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h6><p>当动态方法解析和备援接收者都没有进行处理的话，就会执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</div></pre></td></tr></table></figure></p>
<p>这个方法也是objc里面NSObject.h里面的方法，我对People进行如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    NSLog(@&quot;%@ can&apos;t handle by People&quot;,NSStringFromSelector([anInvocation selector]));</div><div class="line">&#125;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;@@:&quot;];</div><div class="line">    return sign;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次运行程序，发现程序没有崩溃，只不过打印出来了“gotoschool can’t handle by People”。<br>forwardInvocation:方法是将消息转发给其他对象。<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/messageforward/forwardInvocation.png" alt="forwardInvocation:"><br>从注释看：对一个你的对象不识别的消息进行响应，你必须重写methodSignatureForSelector:方法，该方法返回一个NSMethodSIgnature对象，该对象包含了给定选择器所标识方法的描述。主要包含返回值的信息和参数信息。<br>实现forwardInvocation:方法时，若发现调用的message不是由本类处理，则续调用超类的同名方法。这样所有父类均有机会处理此消息，直到NSObject。如果最后调用了NSObject的方法，那么该方法就会调用“doesNotRecognizerSelector：”，抛出异常，标明选择器最终未能得到处理。也就是上面的crash:NSInvalidArgumentException。<br>至此，整个消息转发全流程结束。<br>上一个王图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/messageforward/allprocess.png" alt="消息转发全流程"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>接收者在每一步都有机会对未知消息进行处理，一句话：越早处理越好。如果能在第一步做完，就不进行其他操作，因为动态方法解析会将此方法缓存。如果动态方法解析不了，就放到第二步备援接收者，因为第三步还要创建完整的NSInvocation。   </p>
<p>在完整来一遍   </p>
<p>Q:说一下你理解的消息转发机制？    </p>
<p>A:<br>先会调用objc_msgSend方法，首先在Class中的缓存查找IMP，没有缓存则初始化缓存。如果没有找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则执行消息转发。  </p>
<p>1、调用resolveInstanceMethod：方法。允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回YES，重新开始objc_msgSend流程。这次对象会响应这个选择器，一般是因为它已经调用过了class_addMethod。如果仍没有实现，继续下面的动作。   </p>
<p>2、调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非nil对象。否则返回nil，继续下面的动作。注意这里不要返回self，否则会形成死循环。   </p>
<p>3、调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil;传给一个NSInvocation并传给forwardInvocation：。   </p>
<p>4、调用forwardInvocation:方法，将第三步获取到的方法签名包装成Invocation传入，如何处理就在这里面了，并返回非nil。   </p>
<p>5、调用doesNotRecognizeSelector：，默认的实现是抛出异常。如果第三步没能获得一个方法签名，执行该步骤 。  </p>
<p>另附相关<a href="https://github.com/ScottZg/messageForward" target="_blank" rel="noopener">杂乱代码</a>(里面有动态方法解析demo)。<br>转载请注明来源：    [<a href="https://scottzg.github.io/2017/10/25/message-forward/" target="_blank" rel="noopener">https://scottzg.github.io/2017/10/25/message-forward/</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;在面试过程中你也许会被问到消息转发机制。这篇文章就是对消息的转发机制进行一个梳理。主要包括什么是消息、静态绑定/动态绑定、消息的传递和消息的
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="消息转发" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Wireless Development(无线调试)</title>
    <link href="http://yoursite.com/2017/10/23/wireless-development/"/>
    <id>http://yoursite.com/2017/10/23/wireless-development/</id>
    <published>2017-10-23T09:49:37.000Z</published>
    <updated>2017-10-23T09:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Wireless-Development-无线调试"><a href="#Wireless-Development-无线调试" class="headerlink" title="Wireless Development(无线调试)"></a>Wireless Development(无线调试)</h4><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>这个功能的出现，方便了开发者的调试，尤其是对于AR/VR和相机App的开发者、开发健身应用的开发者、开发穿戴设备应用的人员。因为这些开发者都需要时不时地移动。同时也支持Apple TV开发者。</p>
<h6 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h6><p>使用此功能的前提就是有一台iOS11+的设备、macOS 10.12.4+系统、Xcode 9.0+。</p>
<h6 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h6><p>打开Devices and Simulators，使用Lightning或者USB数据线连接你的设备到Mac计算机。此时你会发现一个新的选项：Connect via network:<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/debugging%20inxcode/via_connect.png" alt="Devices and Simulators"><br>当你选中Connect via network之后，你会发现设备名称那边出现一个地球图标：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/debugging%20inxcode/withvia.png" alt="with via"><br>当出现整个地球图标的时候，你就可以把线拔掉了，然后在无线网络上继续开发你的应用。<br>还有一个小问题，如果你的移动设备和Mac不在一个wifi网络，例如，你的手机用的wifi，电脑用的网线，此时如果你用数据线连接，你会发现如下情况：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/debugging%20inxcode/withline.png" alt="with line"><br>如果你没有用数据线连接，你会发现如下情况：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/debugging%20inxcode/noline.png" alt="no line"><br>在没有数据线连接的情况下，右击你的设备你会发现多了一个Connect via IP Address的选项，点击之后便会让你输入你所选设备的ip，找到你的设备ip，然后连接即可（我这边亲测，没有成功，也许是我们这边网络限制）。</p>
<h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p>1、<a href="https://developer.apple.com/videos/play/wwdc2017/404/" target="_blank" rel="noopener">WWDC对其介绍</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Wireless-Development-无线调试&quot;&gt;&lt;a href=&quot;#Wireless-Development-无线调试&quot; class=&quot;headerlink&quot; title=&quot;Wireless Development(无线调试)&quot;&gt;&lt;/a&gt;Wireless D
    
    </summary>
    
    
      <category term="Wireless Development" scheme="http://yoursite.com/tags/Wireless-Development/"/>
    
      <category term="无线调试" scheme="http://yoursite.com/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>程序人生--拍摄婚纱照经历小记</title>
    <link href="http://yoursite.com/2017/10/12/take-marry-photos/"/>
    <id>http://yoursite.com/2017/10/12/take-marry-photos/</id>
    <published>2017-10-12T13:40:27.000Z</published>
    <updated>2017-10-12T13:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>想想拍婚纱照也算是人生的一件大事了，有必要记录一下。</p>
<p>我们是2017年4月9号定下了去某夫人拍婚纱照。前期也做了大量调研，包括是影楼好还是工作室好等等。后来想想还是要相信大品牌，所有就选了某夫人。</p>
<p>从4月9号定下来到9月9号完全拿到成品，历时153天，也就是5个月左右的时间。时间长的主要原因有两点：</p>
<p>　　1.拍婚纱照人太多，需要排期</p>
<p>　　2.选片时间推迟（想在周六日去选片，但是前面的时间都已经预约完了，所以只能往后推迟）</p>
<p>我们预约是在4月9号，选礼服是在6月12号，拍摄是在6月14号，原计划是9月2号取件，但是由于商家说成品没有做完，所以推迟到了9月9号（成品没做完还没打电话提前通知，要不是我提前打电话问了一下，自己就要空跑一趟了）。</p>
<p>介绍一下拍婚纱照需要注意什么？</p>
<p>第一点：选哪家拍摄。个人建议最好还是选一些大点的知名的拍摄。如果时间允许，强烈建议可以先去参加一次婚博会（了解更多婚博会可关注微信公众号：婚芭莎中国婚博会），在婚博会上有很多拍婚纱照商家，你可以先都了解一下，再评估自己选哪家。</p>
<p>第二点：拍摄需要注意什么。这个你按照你选择的商家要求来就行了，一般选好商家之后，他们会给你安排选礼服时间、拍摄时间、选片时间、校稿日和取件日等。当然也会告诉你拍之前需要准备的东西和需要注意的事项。（如果没有这些，那么要么换商家，要么只能自己问啦）另外还有一点，就是拍摄场地，一定要和商家确定好拍摄场地。当时给我们看的有好多场馆，过去之后发现就是一大片地，里面有一些场景。后来可能觉得照片少，又去了古塔公园拍了一些。。。。。。当时是真心无语啊。。。。。所谓的场景，我只能呵呵了。好在室内景还差强人意。</p>
<p>第三点：选片需要再加照片吗。一般而言，大多数商家都会在你选片的时候鼓励你多加照片，一张照片的价格几百块钱。在婚博会上听好多商家都说50多张足够了，所以如果要你加照片，请一定要坚定自己的信念。（当时太天真，我们是65张，但是相关人员说65张放到相册里面会很空洞，没有丰富感，就又加了20张。当时真的是被忽悠了）</p>
<p>第四点：校稿一定要细心。在某夫人拍婚纱照过程中最让人不满意的就是校稿了，就是你选过的照片需要精修，然后自己要看一下精修照片，看是否有问题。当时我是真想骂人。85张精修照片像没有修过一样，穿帮的比比皆是，照片改了n便，提了n次建议。我想说：精修人员你是用美图秀秀一键美化的么？更让人无语的是，MD 85张照片用邮箱发我，还不压缩，让我一张一张下载，真的是忍不住骂街了。</p>
<p>第五点：成品校验是否合格。在某夫人的经历前期还不错，总监的拍摄团队。后期精修的设计师就不提了（不是一般的low），后期成品还有一张脸花的，说是模板的问题，模板大，照片小，所有出现花脸现象，我想说你们放模板的时候就没有考虑这个问题么？这里差评！后来一个相册又重新制作，才差强人意。</p>
<p>另外，还有就是你的套餐是不是1对1拍摄，因为有的是1对2（这里要看你能否接受1对2拍摄了），也就是一个摄影师同时给2对甚至更多对拍摄，这样会浪费很多时间。我们当时的是1对1，从上午的5：30从家里出发到拍摄基地，到最后回家的时候是晚上8点左右。1天的拍摄还是很累的。最好带一些水，零食是顾不上吃的。</p>
<p>简单注意的就这几点，希望拍婚纱照的亲们一定要注意。当时我拿到成品感觉真心不值，套餐价7999，后来加了一些照片，加起来1W左右。</p>
<p>真心觉得某夫人不怎么样，刚开始的服务和拍摄还差强人意，后期简直不忍直视。我虽然没有选择韩国艺匠，但是拍过的同事说还不错，你可以了解一下韩国艺匠。好几个同事是在那拍的，效果还不错。</p>
<p>简单介绍，如有其他疑问，随时交流沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想想拍婚纱照也算是人生的一件大事了，有必要记录一下。&lt;/p&gt;
&lt;p&gt;我们是2017年4月9号定下了去某夫人拍婚纱照。前期也做了大量调研，包括是影楼好还是工作室好等等。后来想想还是要相信大品牌，所有就选了某夫人。&lt;/p&gt;
&lt;p&gt;从4月9号定下来到9月9号完全拿到成品，历时15
    
    </summary>
    
    
      <category term="婚纱照" scheme="http://yoursite.com/tags/%E5%A9%9A%E7%BA%B1%E7%85%A7/"/>
    
      <category term="程序人生" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何统计iOS产品不同渠道的下载量？</title>
    <link href="http://yoursite.com/2017/08/22/marketing-campaign/"/>
    <id>http://yoursite.com/2017/08/22/marketing-campaign/</id>
    <published>2017-08-22T14:47:15.000Z</published>
    <updated>2017-08-23T02:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h1><p>在开发过程中，Android可能会打出来很多的包，用于标识不同的商店下载量。原来觉得苹果只有一个商店：AppStore，如何做出不同来源的统计呢？本篇文章就是告诉大家如何做不同渠道来源统计。</p>
<h1 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a><strong>二、正文</strong></h1><p>先看一下苹果自家统计到的数据：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/resource.png" alt="img"></p>
<p>这个是在没有对下载链接做任何处理的情况下在itunesconnect后台看到的数据。怎么看到这个页面呢？</p>
<p>登录<a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">https://itunesconnect.apple.com/</a> —&gt;App分析—&gt;点击任一款app—&gt;来源—&gt;App引荐来源。通过这几个步骤就能看到不同app的引荐来源。另外，还能看到网页的引荐来源：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/webresource.png" alt="img"></p>
<p>个人还不太了解具体苹果爸爸那边是怎么实现的，也许是苹果那边对来源进行了记录吧。</p>
<p>接下来我们就来实现这样一个需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我想在多个网页或者APP上对自己的APP进行推广，想大概统计一下某个来源的下载量，如何实现？</div></pre></td></tr></table></figure>
<p>答案就是使用苹果itunesconnect后台的营销活动。</p>
<h2 id="何为营销活动？"><a href="#何为营销活动？" class="headerlink" title="何为营销活动？"></a><strong>何为营销活动？</strong></h2><p>在苹果官方的小提示里面是这样写的：进行 App 和网站推荐跟踪，以便衡量广告营销活动的影响力。</p>
<p>因此我们可以通过生成营销活动链接，然后将原来引导到AppStore的链接换成此营销活动链接，就能够统计某个渠道的展示次数、APP购买量、营销额和APP使用次数。</p>
<h2 id="如何生成一个营销活动链接？"><a href="#如何生成一个营销活动链接？" class="headerlink" title="如何生成一个营销活动链接？"></a><strong>如何生成一个营销活动链接？</strong></h2><p>首先，打开<a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">https://itunesconnect.apple.com/</a>，然后登录开发者账号。然后点击App分析</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/app_analy.png" alt="img"></p>
<p>第二步：点击你要进行营销推广的App，进入如下页面：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/resource_arrow.png" alt="img"></p>
<p>第三步：点击来源，然后选中营销活动：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/show_recordinfo.png" alt="img"></p>
<p>第四步：点击右上角的生成营销活动链接，进入如下页面：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/make_url.png" alt="img"></p>
<p>第五步：输入营销互动，然后在下面的营销活动链接里面复制此营销活动特有的AppStore链接：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/make_url_key.png" alt="img"></p>
<p>然后将此营销活动链接告知网页或者其他APP即可，比如我现在用的是blogtest，那么我的营销活动链接就是：</p>
<p><a href="https://itunes.apple.com/app/apple-store/id1216088977?pt=118341905&amp;ct=blogtest&amp;mt=8" target="_blank" rel="noopener">https://itunes.apple.com/app/apple-store/id1216088977?pt=118341905&amp;ct=blogtest&amp;mt=8</a></p>
<p>原有的AppStore下载链接是这样的：</p>
<p><a href="https://itunes.apple.com/app/apple-store/id1166475483" target="_blank" rel="noopener">https://itunes.apple.com/app/apple-store/id1166475483</a></p>
<p>相当于多个一个pt的参数、ct的参数和mt的参数。其中的ct就是我们的营销活动。</p>
<p>那么我就可以通过下面找个页面来查看通过该营销活动链接该APP的展示次数、App购买量、营销额以及App使用次数等。</p>
<p> <img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/yingxiaohuodong/activity.png" alt="img"></p>
<p>这样，我们就能统计到不同渠道的下载量了。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>做市场推广的时候也许会用到这个功能，个人觉得还是很实用的。感兴趣的话可以自己尝试一下。这里注意，这个数据展示一般是有2天的时间延迟。</p>
<p>转载请标明出处：<a href="http://supermokey.com/2017/08/22/marketing-campaign/" target="_blank" rel="noopener">http://supermokey.com/2017/08/22/marketing-campaign/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;在开发过程中，Android可能会打出来很多的包，用于标识不同的商店下载量。原来觉得苹果只
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="营销活动" scheme="http://yoursite.com/tags/%E8%90%A5%E9%94%80%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序员驾考宝典</title>
    <link href="http://yoursite.com/2017/07/22/my-road-get-driving-license/"/>
    <id>http://yoursite.com/2017/07/22/my-road-get-driving-license/</id>
    <published>2017-07-22T00:41:02.000Z</published>
    <updated>2017-07-24T03:14:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>大学的时候就想着考驾照，但是由于时间原因+金钱原因，没有考。因此选择了工作之后再考。从今年（2017）4月2日到7月18日，历时107天（3个多月），成功拿到了驾照。本文主要是对我整个考驾照之路的记录与总结。希望也能帮助到大家。<br>另外，我是在北京考的驾照，所以下面所有的信息都是北京相关、驾校都是和海淀驾校(以下也简称海驾)相关。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>该文章主要的内容如下：<br>一. 如何选择驾校？<br>二. 报考准备材料以及报考流程<br>三. 科目一的学习与考试<br>四. 科目二的学习与考试<br>五. 科目三的学习与考试<br>六. 科目三安全理论知识（科目四）的学习与考试<br>七. 驾照领取<br>八. 总结<br>九.致谢<br>接下来就从上面的几点进行介绍。</p>
<h4 id="一-如何选择驾校"><a href="#一-如何选择驾校" class="headerlink" title="一. 如何选择驾校"></a>一. 如何选择驾校</h4><p>在北京，驾校很多，海淀驾校、龙泉驾校、东方时尚驾校、远大驾校、京都府驾校、远航驾校等等。那么到底该如何选择报考哪一家呢？<br>当时我是和另一个大学同学一起报考驾校。所以我们都在纠结报考哪个驾校。因此前期在网上看了好多驾校信息，后来对比了各驾校的名气和大小，而且在网上能搜到好多关于默默教练的信息，而这个教练就是海淀驾校的。因此我们最终选择了海淀驾校（是不是很任性）。还加了默默教练的微信号（wangt0209），然后又加了一个他建立的QQ群（感兴趣可以加一下了解：234624273）。这样，我们就确定了要去海淀驾校去考驾照。<br>你也许会问一个问题：海淀驾校报考便宜么？由于工作原因，我们考驾照只能在周六周日，看了一些各个驾校的学习套餐，几乎都有周末定制班，也就是只有周末过去学习，其他时间正常上班。我们报名的时候海淀驾校的这个周末定制班的价格是5800，相比与其他的驾校，价格还算可以。这里我想强调一点：考驾照不能图便宜，正规的驾校才是你优先考虑的。如果你不知道哪个驾校正规，那么你可以亲自去驾校看一下，了解了解。虽然我们没有亲自去驾校考察，但是在接下来的学习工程中，我们发现我们报考海驾是正确的。<br>另外，你还需要考虑一下驾校班车情况，也就是你从你住的地方到驾校是否方便乘坐班车。这个很重要，要不然太远了你还要打车过去，太麻烦了，还浪费钱。一般你选择驾校前都要先咨询(可以直接在官网找客服电话)，咨询一下你关心的问题：需要什么材料、班车情况、从报考到拿到驾照需要多长时间等等。所以如果客服告诉你班车情况后，你发现自己住的地方不太方便乘车，个人观点你就可以换其他驾校了。<br>总之，在选取驾校的时候，只要价格符合你的预算、乘车方便、驾校正规，你就可以确定要报考这个驾校了。</p>
<h4 id="二-报考准备材料以及报考流程"><a href="#二-报考准备材料以及报考流程" class="headerlink" title="二. 报考准备材料以及报考流程"></a>二. 报考准备材料以及报考流程</h4><p>选择好驾校之后，咨询了一下教练需要哪些材料：本人身份证、居住证或居住卡、1寸白底照片6张。然后就着手准备这些材料。</p>
<h5 id="本人身份证"><a href="#本人身份证" class="headerlink" title="本人身份证"></a>本人身份证</h5><p>如果你本人没有身份证，我想你也不会看到这个博客了吧。<br>如果你本人身份证丢了，有临时身份证，刚才咨询了一下，也是可以直接去报考。<br>如果你本人身份证丢了，又没有临时身份证，只有一个证明的话，这个我也不太清楚了，可以咨询一下默默教练(微信：wangt0209)。</p>
<h5 id="居住证或居住卡"><a href="#居住证或居住卡" class="headerlink" title="居住证或居住卡"></a>居住证或居住卡</h5><p>这里先简单介绍下居住证和居住卡的区别：<br>居住卡：全名叫做北京市居住登记卡。它的有效期是是6个月。先看看它长什么样子：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/IMG_0287.JPG" alt="居住卡"></p>
<p>居住证：这个我没有办理，但是有一点你需要知道，就是居住证的有效期是1年。</p>
<p>如果你是自己的房子，那么自己应该就有居住证了吧。<br>如果你是租的房子，那么你可以找中介或者房东咨询一下如何办理居住证或者居住卡。这里我真的要感谢我们的房东张姐。给张姐说了一下我要考驾照，然后需要居住证或者居住卡。张姐立马就给予帮助，告诉我先到居委会咨询一下需要办理需要什么材料。经过了解知道以下的东西：<br>如果你想办理居住卡，你需要准备的材料如下：</p>
<ul>
<li>本人1寸白底照片1张</li>
<li>房屋租赁合同</li>
<li>房东身份证复印件</li>
<li>房本复印件</li>
<li>本人身份证复印件</li>
</ul>
<p>我把需要的材料给房东张姐说了一下，张姐就立马把房东身份证复印件和房本复印件给我发了过来。然后我拿着材料去居委会，用了不到10分钟，就办成了居住卡。</p>
<p>如果你想办理居住证，你需要准备的材料如下：</p>
<ul>
<li>居住卡(也可以用上面办理居住卡的材料替代)</li>
<li>本市6个月的社保缴纳记录。(这个需要去<a href="http://www.bjrbj.gov.cn/csibiz/indinfo/login.jsp" target="_blank" rel="noopener">官网</a>下载打印，而且需要预约下载。名额每天有限，如果你预约晚了就只能第二天再次预约下载了。)</li>
</ul>
<p>如果你办理居住证或者居住卡遇到困难，比如房东材料没有或者不给的话，你也可以直接联系默默教练，让默默教练帮你想办法。</p>
<h5 id="1寸白底照片"><a href="#1寸白底照片" class="headerlink" title="1寸白底照片"></a>1寸白底照片</h5><p>照片要求如下：露耳朵、近视的话要带近眼睛。其他就没有特殊要求了。如果说你拍照片的时候眼睛有些反光，你可以让摄影师帮你修一下，只要不是太明显，问题不大。我当时的照片就有眼镜反光，但是没有影响使用。</p>
<p>到此，报考准备材料准备结束。<br>接下来就是去报名。<br>你会发现你附近也有好多驾校报名点，个人觉得你直接去驾校报名就行了，到驾校更保险，万一遇到冒名顶替的报名点呢？<br>在4月2日，我和同学在我们小区门口坐上了10：45左右去海驾的班车(如果让刷卡，你直接说是去报名就行)。到了驾校，你可以直接联系默默教练，他会带你去报名。如果教练不在驾校的话，你可以下车之后自己去报名中心（海驾我记得是1号楼）报名。到了之后你可以咨询前台，就说你是来报名的，然后你按照他们的指示做就行。我去的时候是默默教练带着我们去的，到了报考大厅，我们首先是报名缴费，然后需要体检（体检是在报名点（需要交10元体检费），不用担心），录指纹（一定要记着你录得哪个指纹，因为接下来考试学习都要用到指纹）。最后驾校会给你一些资料和科目一的学习以及预考信息，然后你就可以拿着这些东西，坐上了下午回去的班车，回家准备学习约考了。<br>这里还是要感谢默默教练，直接带我们去报名，省了我们自己去找报名中心。</p>
<p>对了，如果你报的是海驾，你最好下载几个软件：海淀驾校、考驾宝典、学车不。他们会在你学习过程中带来很大的帮助。你可以在海淀驾校APP上查询自己如何乘坐班车，首先绑定自己的位置站点，然后可以查看实时班车：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/haidianjiaxiao.jpg" alt="海淀驾校APP"><br>接下来就正式进入学习考试阶段了。</p>
<h4 id="三-科目一的学习与考试"><a href="#三-科目一的学习与考试" class="headerlink" title="三. 科目一的学习与考试"></a>三. 科目一的学习与考试</h4><p>这部分主要分为如何进行科目一的学习与考试。先说明一下，科目一考试共100道题（选择题和判断题），每题1分，90及以上算合格。</p>
<h5 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h5><p>科目一的学习分为两种：一种是在校学习，一种是网络教学培训。因为没时间在校学习，所以选择了网络教学培训。<br>打开<a href="http://xuexi.xuechebu.com" target="_blank" rel="noopener">http://xuexi.xuechebu.com</a> ，然后按照提示使用手机号注册，然后就可以在在线课堂里面进行科目一理论的学习。学习的时候需要注意：每天学习时间不能超过4学时，总学时为12学时（可以重复学习）。因此我我每天都会看上面的视频教学（我这里是用电脑看的，如果你想用手机看，可以使用学车不APP进行学习）。另外，上面提到的考驾宝典是个非常好用的软件，里面包含了科目一最新的题目，一共1325道题，只要把那些题目弄会，完全不用担心考试不会过。而且里面还有模拟考试题，对科目一的学习很有帮助。我每天就是在上班的路上拿着手机在驾考宝典上刷题:<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/%E9%A9%BE%E8%80%83%E5%AE%9D%E5%85%B8.jpg" alt="驾考宝典"><br>我在看题的时候是使用答题模式，如果题目答对了就直接过，如果没有答对，就直接截图保存到手机，过段时间在看看截图上的错题。<br>把网络教学视频看完之后，约考是24小时后在<a href="https://bj.122.gov.cn/" target="_blank" rel="noopener">https://bj.122.gov.cn/</a> 上进行考试预约。首先注册，然后点击我的主页，选择驾驶证业务，即可在里面进行预约考试。页面如下：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/122.png" alt="122平台"><br>然后点击本地考试预约，选择相应的时间和考试地点即可。</p>
<h5 id="关于科目一考试"><a href="#关于科目一考试" class="headerlink" title="关于科目一考试"></a>关于科目一考试</h5><p>我约考试是在4月17日上午，所以请了半天假，早早地坐上了6：45左右的班车去驾校。到了驾校，先到6号楼1楼看电子屏幕上的提示，上面会写到哪层哪个教室等待考试。<br>到了指定教室之后，大概8点(这里特指上午约考的时间)，有个老师会讲一些基本的东西，然后发准考证，出门按照老师指示排队候考。<br>到考场门口之后，首先要将手机关机，然后刷身份证确认是否是本人，确认之后在考场门口排队，然后有序进场，这里注意，只要考场有人考完离开，就按照顺序进入即可，是循环考场。<br>进入考场后，看自己考试的机子，按照提示输入身份证号(用鼠标输入，也可用小键盘输入)，然后检测指纹(左手或者右手食指，也就是你原来录入的指纹，如果原来没有录入指纹的刚到6号楼就在一层办理录入指纹)，指纹检测成功后，即可进入答题。<br>答题完毕后点击交卷，然后从左侧门口出去，门口有成绩单发放，注意查看自己的成绩单，不要拿错。<br>拿到成绩单之后，按照他们的要求在前台签名，然后在把成绩单和准考证交给前台，她会给你的计时培训预约卡上贴一个标签。贴完标签以后，到4号楼1层前台咨询约车，他们会先拿你的预约卡登记(应该是登记，反正在那刷)，登记完了自己去自助约车处将卡插入，选择自己想要训练的时段即可，然后会打印约车条(这里有名额限制，如果周六的上午名额用完了，那么只能约其他时间了)。我是定制班，所以我是一次性把所有车约完，我考试时间是4月17，但是由于人多，我约到的科目二第一次培训都到5月7日了。如果你觉得中间间隔时间太长，你也可以自己约车（不建议自己约车，因为人多，不太好约），然后按照约的时间进行培训。我是一次性把所有科目二的车都约了，是每周末的上午8：00-11：30，从5月7日到5月29日。另附无法直视的约车条：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/yueche.JPG" alt="约车条"><br>至此，科目一结束，保存好约车条，就可以回去了，然后按照条上的时间练车即可。</p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>科目一整体来说还是很简单的，只要你把驾考宝典上的题目都看看，一般很容易过。如果看都不看，直接去考试，挂的几率还是很大的。强烈建议大家先看，然后再约考，要不然万一挂了就还要再次约考试，还要交补考费。</p>
<h4 id="四-科目二的学习与考试"><a href="#四-科目二的学习与考试" class="headerlink" title="四. 科目二的学习与考试"></a>四. 科目二的学习与考试</h4><p>这部分主要介绍科目二的学习与考试经历。科目二考试为电子监考，考试内容包括：坡定坡起、曲线、直角转弯、侧方停车和倒车入库。满分100分，80分合格。</p>
<h5 id="关于学习-1"><a href="#关于学习-1" class="headerlink" title="关于学习"></a>关于学习</h5><p>拿着科目一考试完之后的约车条，按照上面的时间去学习即可，不要忘了带培训手册和计时卡（两者都是报名的时候发的）。每次去训练的时候你要先到4号楼去刷上车卡，到了4号楼大厅里面会有上下车刷卡的地方，排队就行，轮到你了就把预约卡放卡槽，然后将手指放到指纹识别处，识别成功后会有一个约车条，拿着去找教练就行。你也许会问，去哪找教练呢？看看约车条，上面有教练车号（我的是05171），然后根据车号找车就行。车号前两位代表的含义，这里注意：</p>
<ol>
<li>02：爱丽舍：海驾一桥西侧找车</li>
<li>05：桑塔纳：过海驾一桥一号停车场</li>
<li>07：模拟器：11号楼西侧模拟器室第三训练队负责</li>
<li>08：比亚迪： 学员餐厅（5号楼）对面停车场找车（为科目三训练车辆）</li>
</ol>
<p>我的是05，所以是桑塔纳，按照上面的位置找车就行（如果不知道上面的位置，直接找人问就行）。<br>科目二的培训和考试内容为：倒车入库、侧方位停车、直角转弯、坡道起步停车、曲线行驶和倒车入库。<br>网上也有很多教程，其实大家可以忽略，按照教练教的来就行。每次培训完之后，记得打开海淀驾校APP，然后点击首页的签到签退，拿手机扫教练的手机签退。<br>科目二的学习真的要感谢我的教练：杨教练(手机号：136-6136-5614)。原来听别人说教练都很凶，动不动就生气，但是我遇到的杨教练真的很好，而且在训练的过程中如果我热了还帮我把车上的空调打开，练得累了就让我休息会。完全不像原来别人说的那样，而且杨教练很友好，经常教一些科目二的小技巧等。如果大家想报名也可联系杨教练。<br>想了想，这里就不在具体介绍各个考试内容如何实现了，因为你只要按照教练教你的去学习就行了。一定没问题。</p>
<h5 id="关于约考和集训"><a href="#关于约考和集训" class="headerlink" title="关于约考和集训"></a>关于约考和集训</h5><p>学习完所有预约时间段之后，你就可以24小时之后约科目二考试了。和科目一考试一样，也要去122平台约考，这里一样注意约考时间和考试地点。因为要上班，但是考试不能在周六周日，所以我约到了周一下午考。而且科目二考试有集训。所谓集训，就是考试前一天几个人一个教练，教练会带学员进行训练，时间为早8：00到晚8：00。所以如果你约周一上午考，那么你周六集训；如果你约周一下午考，那么你周日集训。我约考是在5月29下午考试。所以周日集训。集训期间还认识一位老乡，和其他几位学员。<br>我们集训的教练也姓杨(手机号：130-3100-5658，想要报名也可以联系他)，这个杨教练也很好，很耐心地指导我们5个练习。让我更有底气去应对科目二考试。</p>
<h5 id="关于科目二考试"><a href="#关于科目二考试" class="headerlink" title="关于科目二考试"></a>关于科目二考试</h5><p>(2017年6月5日)考试科目二，今天整体来说有点紧张，可以说是险过。<br>今天请了一天病假，然后在家呆着准备去考试。坐上10:49的班车，然后到了驾校就匆忙跑去12号楼待考大厅。准备考试。我几乎是在最后才考的(后面还有40多个人左右)。说一下考试流程。在待考厅看屏幕自己所用的车序号(这里注意，有的时候由于其他学员考试太慢，导致待考大厅里面的大屏幕没有显示自己的名字，很正常。)，等待点名，点到的拿身份证到窗口核对信息，无误之后出门，然后把自己携带的包什么的存到寄存箱里(寄存箱需要你先设置密码在存储。具体操作上面也有写)。随后带着身份证在门外待考区等待喊自己的名字，只要听到有人喊你的名字就会同时告诉你。喊到你就上车。<br>坐上车之后有，把身份证放到副驾驶座上。首先调整一下座椅，然后调整后视镜，再系上安全带。根据引导员的指示起步。你开始走的时候就打左灯，因为你等待区域前面就是坡定坡起，所以当引导员问你准备好没？如果你准备好了，车子就报开始考试，此时你的车已经到黄线，就打右灯准备坡定坡起。具体的后面就和平时训练的一样了。<br>考试内容的顺序为:坡定坡起，曲线，直角，侧方，倒车入库。<br>科目二考试也是有两次机会的，我在考试过程中由于坡起没有找到结合点而失去了第一次考试机会，这个时候就驶出了坡定坡起考试区域，到了曲线。平复了一下心情之后，右手示意可以进行二次考试，继续考，后面的几个都比较顺利。然后倒车入库后又进入到了坡定坡起，这里有了上次的经验，所以注意了一下结合点。谁知道又熄火了。这个时候千万不要紧张，立刻重新打火。第二次打火通过了考试区域。然后机器报考试结束，考试合格。然后我就通过曲线走到了初始区域，下车让其他学员继续考试。<br>考试过程中难免有失误，失误之后不要紧张不要着急，立马重新继续。比如在坡起时，如果熄火就立刻打火，熄火再打火，不要熄火之后就放弃。其他内容也是一样。<br>这里我个人觉得一下几点应该注意:</p>
<ol>
<li>一定要提前找好结合点。</li>
<li>一定要放平心态。</li>
<li>车子有的时候会有问题，比如我遇到的车子调镜子的按钮就坏了，而且档位那个用着也很别扭。不好去档，也不太好挂档。此时一定不要埋冤，(可以向引导员反应一下)如果不行就只能上了，箭在弦上不得不发。</li>
<li>靠背位置一定要调整好。很重要。所以一定要先调座椅再调后视镜。</li>
</ol>
<p>考试完之后，回待考大厅签字确认一下成绩，然后立马去4号楼大厅确认考试合格和约科目三的车，要不然晚了时间就越靠后。然后就可以回家静静等待科目三的训练了。我去到约车机器那之后能约的科目三培训都到7月2日了，自己又不着急，所以就约了7月2日、7月8日和7月9日三天下午的培训。附约车条：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/threetraing.jpg" alt="科目三约车条"></p>
<h5 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h5><p>科目二个人觉得是考驾照过程中最难的一个科目，而且是电子考，全程只有你一个人在车里面，按照电脑的指令考试。有一点差错就会被机器检测到。但是只要你培训过程中认真学，不懂就多问，集训的时候在认真练练，想过就很简单了。另附一张考试图记录：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/kemuerkaoshijilu.jpg" alt="科目二考试图记录"></p>
<h4 id="五-科目三的学习与考试"><a href="#五-科目三的学习与考试" class="headerlink" title="五. 科目三的学习与考试"></a>五. 科目三的学习与考试</h4><p>这部分主要记录一下科目三的学习、集训以及考试。科目三是路考，包括模拟夜间灯光考试和路考。满分100分，90分合格。</p>
<h5 id="科目三学习"><a href="#科目三学习" class="headerlink" title="科目三学习"></a>科目三学习</h5><p>按照科目二考试结束后约车时间来驾校上课即可。第一次过来是7月2号，主要是模拟器训练，具体训练内容也不在介绍，按照训练室老师说的来就行。很简单。模拟器训练时拍了一张考试题：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/monidengguangkaoshi.jpg" alt="模拟夜间灯光考试"><br>由于拍的不太清晰，我这边就直接从新在备忘录写了一遍，直接上截图。这个是科目三的考试内容，科目三包括了灯光考和路考。路考前，考官会先发出上面的指令，然后你要按照指令做相应的灯操作。<br>后两次就是实路训练。和科目二一样，来了也要先刷上车卡，然后走的时候找教练刷下车卡。<br>科目三训练的教练姓孟(手机号：132-4127-8924)。孟教练也是态度很好，而且很幽默。让我在学习过程中毫无压力，而且学到了好多。因为在科目二培训过程中，是没有用到各种灯和油门的。科目三是模拟的真实上路情形。孟教练用很幽默的方式告诉我怎么用各种灯和油门以及其他部件。<br>科目三训练过程中，孟教练首先带我在训练路段训练，然后又到考试的北一和北二考场转了几圈，让我熟悉考场。接着又到集训场地进行了训练。<br>科三刷下车卡的过程中，总是刷不上去下车卡，孟教练就直接拿了一张纸，然后让我写了一个条，然后他替我交了。就这样两次培训都是教练帮我交了下车刷卡条（如果能够正常刷下车就不需要手动写条）。<br>在孟教练的训练下，我很快地掌握了上路技巧。<br>培训完之后24小时，我便在<a href="http://bj.122.gov.cn/" target="_blank" rel="noopener">122</a>上约了科目三的考试(时间7月17日下午)。和科目二一样，也有集训，只不过集训的时间是早8：00到下午4：00左右。</p>
<h5 id="科目三集训"><a href="#科目三集训" class="headerlink" title="科目三集训"></a>科目三集训</h5><p>科目三集训的时间是7月16日。坐上早上6：45左右的班车，到了驾校，此时不需要刷卡，直接到科三停车场最左边的公示栏前面坐车去集训场。注意不是做教练的车过去，科三训练停车场里面有两个公交车，坐公交车过去。怎么坐车呢？看公示栏：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/kesanjixun.JPG" alt="科三集训坐车"><br>集训的教练姓边（手机号：136-7139-7587，报名也可直接联系边教练），是位女教练。同样是5个人集训，然后在集训地点训练。集训时边教练说了考试的时候注意事项：</p>
<ol>
<li>不要忘记带身份证</li>
<li>远近光交替的时候要搬动三次</li>
<li>看仪表盘速度减档加档（不要刻意去看），如果速度20以下可以直接越级减档</li>
<li>上车一定要观察仪表是否正常</li>
<li>变道一定要先观察后视镜。</li>
<li>如果科目三你在后面坐，一定要系安全带</li>
</ol>
<p>科目三集训完之后，坐公交车来到驾校，此时在公示栏已经贴出来了自己考试的场次以及组数。如下图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/kaoshi3xinxi.jpg" alt="科三考试信息"><br>在公共栏找到自己的信息，查看相应的考场和组就行，然后次日按照上面的要求乘车过去考场准备考试。</p>
<h5 id="科目三考试"><a href="#科目三考试" class="headerlink" title="科目三考试"></a>科目三考试</h5><p>7月17日上午坐班车到了驾校（到驾校时间大概是11：30左右），然后在三号楼前面按照路面的车位找到了去考试场的班车(我是北一考场)。然后等着去考场的车。如果来驾校的时候没吃饭，可以去1号楼前面的那个楼吃饭。吃完饭在1号楼等去考场的车。车是1:10分去考场，注意把握时间。<br>到了考场，按照你的分组在路边找相应的组，然后找那边等待的教练，按照他的要求签字，然后那个教练会按照名字排序，按照他的指示站位就行。这里注意:你所在的组会有不同车型不同驾校的学员。所以即使你在科三考试条上写的是最后一个，后面也许还会有其他驾校学员。<br>过了一会考官会过来，然后他也有个单子，他会将考试顺序重新调整，然后开始准备考试，第一个人上车，第二个人在车后面坐着，并且第二个人一定要记住系安全带。<br>轮到你在后车厢坐的时候，直接坐上车，系好安全带，不要说话。静静地坐着看就好。<br>轮到你的时候，首先打开车门出去，然后顺时针走到驾驶人那个位置(此时你上一个考试的还在上面)，你直接喊一声报告，然后逆时针围车转一圈再走到驾驶人位置(如果你走到车正前方发现上一个考试的学员还没有下车，你要在车前方等待，等他下车后再上车)，再喊一声报告，不用等考官回应即可上车。<br>上车时记得把身份证拿在手里，然后上车。首先自报家门”考官您好，我是海淀驾校学员某某某，这个是我的证件”，双手拿证件对着考官。然后考官会把证件接过来，会对你说:”开始准备”。你就开始准备工作，调整座椅，系安全带，看一下仪表和镜子(后视镜和车里面的后镜)，然后你说各仪表正常，请求考试，然后考官开始考灯光，这里注意，当考官说关闭所有灯光时，记得把双闪也关了，因为上一个学员靠边停车会把双闪打开。接着考官会说开始起步，然后一定要记得打左转向灯，并且看一下后视镜，了解左侧车道路况之后再进入左邻车道。然后行驶期间就按照考官指令做就行:转弯，调头，提取等等，记着灯光的使用就行。当考官说靠边停车时，开右光灯，然后缓慢在路边停下即可(这里注意，不用靠路边太近，集训时说不要靠太远。你刚从班车下车那个教练会说只要进入白实线就行)。停车后，拉手刹，摘档，关转向灯，开双闪。考官会告诉你成绩，然后让你签字。签完字就下车，然后找教练(刚下班车那个教练)确认一下，告知他你的考试结果即可。最后，坐班车（我是不想等班车，就直接10块钱打车去了驾校）回驾校，直接在1号楼客服中心预约次日的科目三安全理论考试。约完之后就等着坐班车，准备明天的科目三理论考试就行。<br>我考试的过程都很顺利，唯一的失误就是在起步的时候忘记了打左灯。大家在考试的时候一定要注意。</p>
<h5 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h5><p>科目三相比科目二来说简单一些，但是也要好好学，一定要注意灯光的使用和加档减档。还有就是在考灯光的时候一定不要紧张，如果没有听清楚考官说的什么可以请考官重复。</p>
<h4 id="六-科目三安全理论知识（科目四）的学习与考试"><a href="#六-科目三安全理论知识（科目四）的学习与考试" class="headerlink" title="六. 科目三安全理论知识（科目四）的学习与考试"></a>六. 科目三安全理论知识（科目四）的学习与考试</h4><p>科三理论总共50道题目，每题2分，考90以上合格。其中有几道多选题目。</p>
<h5 id="科目三理论学习"><a href="#科目三理论学习" class="headerlink" title="科目三理论学习"></a>科目三理论学习</h5><p>科目三的理论课也是在<a href="http://xuexi.xuechebu.com" target="_blank" rel="noopener">http://xuexi.xuechebu.com</a> 上面学习的，上面有科目三理论，如下图：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/xuechebu.png" alt="科目三理论"><br>和科目一理论一样，看视频学习即可。这里注意：因为我是7月17日下午考科目三，约得7月18日上午考科目三理论，所以我在科三训练的时候已经把科目三理论的网络课程看完了。另外在驾考宝典上也有科目三理论的相关试题，空闲时间看一下就行。</p>
<h5 id="科目三理论考试"><a href="#科目三理论考试" class="headerlink" title="科目三理论考试"></a>科目三理论考试</h5><p>7月18日上午坐班车到驾校考科目三理论，去的时候不要忘记带：</p>
<ol>
<li>2张1寸照片，近视也可以不戴眼镜，帅就行，是往驾照上贴的。</li>
<li>考试计时卡，领取驾照时需要上交。</li>
</ol>
<p>科三考试和科目一考试一样，流程也一样，地点也一样。只不过在考试结束后，如果你考试过了，就拿着成绩单直接去1号楼客服中心即可。如果考试没过，那就直接交补考费等待下次考试即可。我是直接以98分的成绩考过了，所以直接拿着成绩单就去1号楼客服中心了。<br>就这样科目三理论考试通过。</p>
<h4 id="七-驾照领取"><a href="#七-驾照领取" class="headerlink" title="七. 驾照领取"></a>七. 驾照领取</h4><p>拿着科目三理论的成绩单，然后带着2张1寸照片和计时卡，就可以去1号楼客服中心了，到了之后把成绩单和照片交了（有的需要1张照片就够了，有的需要两张）。然后在1号楼的刷卡机用计时卡刷卡，会出来一张条，上面写着：10点之后到二楼等待领取驾照。<br>看时间还早，此时可以去吃点饭，10点之后去客服中心二楼某某教室等待发驾照。<br>因为我想开发票，听说需要拿着驾照、收款单和身份证去财务才能开发票，但是驾照还没有出来，所以我就直接拿着刚才那张条到了财务室(就是客服中心1楼)，财务人很好，直接看了一下我的身份证和收据，然后就给我开了一张发票。<br>开完发票之后，我就去了二楼，然后坐在教室等待驾照发放。教室有个投影仪在播一些视频，告诉新手们注意安全。然后有位培训员过来了，手里拿着驾照。我们需要拿着计时卡上台领取驾照，并且在纸上签字（说明驾照已领）。还发了一张海驾免费陪练单：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/peiliandan.jpg" alt="陪练单"><br>可以申请免费陪练两小时，服务不错。<br>另外，还告诉我们需要办理一张工商银行的牡丹交通卡，如果在北京，这个是必须要办理的。因为如果你违章了，必须要用这个卡交罚款。因此领到驾照之后，我在公司楼下咨询了一下，客服人员给我了一张字条：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/mudanjiaotongkabanli.jpg" alt="牡丹交通卡办理"><br>营业部是不办理的，只网上申请办理。按照上面的步骤办理即可。而且该卡是不收年费的。<br>另附自己的驾照：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/jiazhaozhengmian.JPG" alt="驾照正面"><br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/drivingLicense/jiazhaoneirong%20.jpeg" alt="驾照内容"></p>
<h4 id="八-总结"><a href="#八-总结" class="headerlink" title="八.总结"></a>八.总结</h4><p>自己还是比较幸运的，每次考试都是一次性通过。其实仔细回想整个学车过程，只要你用心去学了，一般都可以过去的。万一哪个科目挂了，补考就行。另外需要注意以下几点：</p>
<ol>
<li>科目一、科目三和科目三安全理论（科目四）是90合格，科目二是80分合格。</li>
<li>在学习过程中一定要多看多记，尤其是理论考试。我在理论时一般都是把对了直接忽略，错的截图隔一段时间就看看。我还有个习惯就是做记录，每次培训之后在回去的班车上都会用备忘录简单记录一下今天学习了什么、自己的失误在哪里以及应该注意什么。后来发现这样做真的很好，能够避免自己再次失误。</li>
<li>不管是哪个科目的考试，一定不要紧张，大不了再补考。你会发现不紧张反倒很容易过。</li>
</ol>
<p>说了这么多废话，总之一句话：只要你对事情上心了，你就会达到你既定的目标。没有人替你去操心，自己的事情一定要自己上心。</p>
<p>最后祝愿没考驾照的同学考驾照的时候都能顺利通过。<br>如果想报驾校，可以找上面的默默教练或者其他教练报名。</p>
<h4 id="九-致谢"><a href="#九-致谢" class="headerlink" title="九.致谢"></a>九.致谢</h4><p>衷心感谢（按照学习顺序排名）：默默教练（报名指导教练）、杨月明教练(科目二培训教练)、杨先林教练(科目二集训教练)、孟凡利教练(科目三培训教练)、边保玲教练(科目三集训教练)<br>衷心感谢房东张姐提供的帮助，让我顺利办理居住卡。<br>衷心感谢驾考宝典开发设计人员。<br>衷心感谢公司同事对我的支持。<br>衷心感谢我爱人对我的支持和照顾，期间起很早给我做饭。</p>
<p>转载请注明出处：<a href="http://supermokey.com/2017/07/22/my-road-get-driving-license/" target="_blank" rel="noopener">http://supermokey.com/2017/07/22/my-road-get-driving-license/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h4&gt;&lt;p&gt;大学的时候就想着考驾照，但是由于时间原因+金钱原因，没有考。因此选择了工作之后再考。从今年（2017）4月2日到7月18日，历时107天（3
    
    </summary>
    
    
      <category term="考驾照" scheme="http://yoursite.com/tags/%E8%80%83%E9%A9%BE%E7%85%A7/"/>
    
      <category term="个人" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa和Cocoa Touch的区别</title>
    <link href="http://yoursite.com/2017/07/13/cocoa-vs-cocoatouch/"/>
    <id>http://yoursite.com/2017/07/13/cocoa-vs-cocoatouch/</id>
    <published>2017-07-13T03:20:48.000Z</published>
    <updated>2017-07-13T06:15:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="含义与区别"><a href="#含义与区别" class="headerlink" title="含义与区别"></a>含义与区别</h4><p>Cocoa和Cocoa Touch都是应用开发环境。他们本身并不是框架，但是里面集成了一批创建应用程序时经常会用到的框架。Cocoa是OS X的应用开发环境，Cocoa Touch是iOS的应用开发环境。它们都包含了OC的运行时和两个核心的frameworks：</p>
<ul>
<li>Cocoa,包含了Foundation和AppKit framework，用来开发在OS X上运行的应用程序</li>
<li>Cocoa Touch,包含了Foundation和UIKit framework,用于开发在iOS设备上运行的应用程序</li>
</ul>
<h4 id="The-Frameworks"><a href="#The-Frameworks" class="headerlink" title="The Frameworks"></a>The Frameworks</h4><p>The Foundation framework实现了基类：NSObject，它定义了基础对象行为。它实现了代表原始类型的类（例如strings和numbers）和collections（例如arrays和dictionaries）。<br>Foundation也提供了一些其他的东西，例如对象持久化、文件管理、XML处理等等。你可以使用它的class去访问系统实体或者服务，例如ports、thread、locks和进程。Founcation是基于Core Foundation framework的（该框架提供了发布一个程序的接口）。</p>
<p>你可以使用AppKit和UIKit来设计用户界面。他俩的作用是一样的，只不过是在不同的平台展示。他们都包括了事件处理、drawing、图片处理、文字处理、等等。<br>他们也包括了用户界面元素，例如table views、sliders、buttons、text field、alert对话框等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;含义与区别&quot;&gt;&lt;a href=&quot;#含义与区别&quot; class=&quot;headerlink&quot; title=&quot;含义与区别&quot;&gt;&lt;/a&gt;含义与区别&lt;/h4&gt;&lt;p&gt;Cocoa和Cocoa Touch都是应用开发环境。他们本身并不是框架，但是里面集成了一批创建应用程序时经常会用到的
    
    </summary>
    
    
      <category term="Cocoa" scheme="http://yoursite.com/tags/Cocoa/"/>
    
      <category term="Cocoa Touch" scheme="http://yoursite.com/tags/Cocoa-Touch/"/>
    
  </entry>
  
  <entry>
    <title>理解cocoa和cocoa touch的响应者链</title>
    <link href="http://yoursite.com/2017/07/12/responder-chain/"/>
    <id>http://yoursite.com/2017/07/12/responder-chain/</id>
    <published>2017-07-12T14:10:32.000Z</published>
    <updated>2017-07-12T14:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>该文章翻译自：<a href="https://medium.com/ios-os-x-development/understanding-cocoa-and-cocoa-touch-responder-chain-12fe558ebe97" target="_blank" rel="noopener">Understanding cocoa and cocoa touch responder chain</a>。</p>
<p>不管是在cocoa中还是在cocoa touch中，所有的Applications都有一个与之关联的事件队列，这个队列里面是许多不同来源的事件。为了处理事件流，每个application都持有一个run loop,此run loop将会以先进先出（first in first out）的顺序接收和派发事件。<br>当一个程序启动的时，对UIApplicationMain的调用将会创建一个UIApplication的单例对象，这个单例对象将会处理和调度系统发送到应用程序事件队列的事件。<br>Application将会接收下面来源的事件：</p>
<ol>
<li>UIControl Actions：这些事使用action-target模式注册的动作，例如button添加的动作。</li>
<li>User events：来自用户的事件，例如touches、shakes、motion等等。</li>
<li>系统事件：例如内存过低、旋转等。</li>
</ol>
<p>在被派发到适合的接收者之前，这些事件都会被上面提到的application单例对象处理一下。</p>
<h4 id="UIControl-Actions"><a href="#UIControl-Actions" class="headerlink" title="UIControl Actions"></a>UIControl Actions</h4><p>UIControl Actions就是我们通过<code>addTarget:action:forControlEvents:</code>方法为control对象添加的action，UIControl对象将会保持并记录所有通过action/target添加的action。<br>当用户在控件上执行事件的时候，或者当一个控件调用<code>sendActionsForControlEvents</code>方法的时候，和该控件相关的action事件将会被发送到注册的target。<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIButton *button = [UIButton new];</div><div class="line">[button addTarget:self action:@selector(buttonTapped) forControlEvents:UIControlEventouchUpInside];</div></pre></td></tr></table></figure></p>
<p>当用户点击这个button的时候，事件将会被调度到UIAppication（使用UIcontrol内部的sendActionsForControlEvents副本），然后application会从事件队列里面读取并且在UIApplication的<code>sendAction:to:from:forEvent:</code>方法里面调度，该方法的基本实现就是将在注册的目标上调用动作，在这种情况下，目标将接收buttonTapped方法。</p>
<p>如果我们把target置为nil：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button addTarget:nil action:@selector(buttonTapped) forControlEvents:UIControlEventTouchUpInside];</div></pre></td></tr></table></figure></p>
<p>此时<code>sendAction:to:from:forEvent</code> 将会将buttonTapped选择器发送到当前第一响应者，如果当前的第一响应者没有实现这个方法，那么它将被转发到下一个响应者，系统将会一直尝试在响应者链中去找一个可用的响应者，直到没有更多的响应者可用。在这种情况下，该操作将会被删除。<br>根据上面所说的，我们可以利用UIapplication单例对象的<code>sendAction:to:from:forEvent</code>方法给第一响应者发送一个动作，将target置为 nil。<br>例如我们可以发送<code>resignFirstResponder</code>消息给第一响应者来隐藏键盘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</div></pre></td></tr></table></figure></p>
<h4 id="User-Events"><a href="#User-Events" class="headerlink" title="User Events"></a>User Events</h4><p>用户事件，例如touch事件和设备运动事件，这些事件发送到application的事件队列里面，如果用户事件是touch事件之外的任何事情，application将会分发这个调用给第一响应者，如果第一响应者无法处理，系统会继续响应者链查找适当的响应者。<br>对于touch事件，流程是不一样的。当系统检测到一个屏幕上的touch，它就会把这个touch发送给application，application会在其 _ touchesEvent内部方法中接收这个touch事件。<br>然后application将会使用sendEvent将此事件转发到UIWindow，收到此事件后的Window会开始测试视图（hit-testing），以便找到接收此touch的视图。<br>UIView将会使用<code>hitTest:withEvent</code>的方法来查找在这个touch事件之下的视图，hit-test会通过调用每个view的<code>pointInside:withEvent:</code>来检查该touch是否在当前view里面。<br>hitTest和pointInside将被递归调用，直到它达到最顶层的叶视图。这个view将会被作为touch的第一响应者来处理这次touch。</p>
<p>UIWindow 会将触摸事件发送到此视图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>
<p>当一个事件发送到一个view的时候，这个view有下面三种选择：</p>
<ol>
<li>由于上述四种方法的UIResponder base实现将事件转发给下一个响应者，那么如果视图没有实现他们的方法，则该方法将被转发到下一个响应者。</li>
<li>视图可以实现上述的任何一种方法，做一些处理，然后调用super，以让下一个响应者做一些额外的过程。</li>
<li>视图可以实现上述任何方法，并选择不将事件转发给下一个响应者。</li>
</ol>
<p>如果视图选择不处理这个touch事件，那么该事件将会发送到响应者链，然后按照下面的路径执行：</p>
<ol>
<li>第一响应者是收到测试的视图(touch下的视图)</li>
<li>下一个响应者是它的父视图</li>
<li>该响应者链在视图层次结构上继续进行，直到达到与视图控制器相关的视图</li>
<li>这个视图控制器将会是下一个响应者</li>
<li>如果这个视图控制器是根视图控制器，那么window就是下一个响应者</li>
<li>application是window的下一个响应者</li>
<li>在响应者链最后的响应者是App delegate</li>
</ol>
<h4 id="System-Events"><a href="#System-Events" class="headerlink" title="System Events"></a>System Events</h4><p>系统也会发送事件给application单例，application单例将会接收这些系统相关的事件，然后把他们派发到App delegate，app delegate将会依次接收和处理这些事件。</p>
<h4 id="The-first-responder"><a href="#The-first-responder" class="headerlink" title="The first responder"></a>The first responder</h4><p>任何的UIResponder对象都可以通过调用或者接收<code>becomeFirstResponder</code>方法来确定是否成为第一响应者，第一响应者将被接收到有机会对用户事件采取行动。然而，touch事件不会被发送到第一响应者，这些事件被发送到通过进行递归命中测试发现的视图。<br>除了上面提到的，第一响应者也会接收到他们的target置为nil的UIControl动作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文章翻译自：&lt;a href=&quot;https://medium.com/ios-os-x-development/understanding-cocoa-and-cocoa-touch-responder-chain-12fe558ebe97&quot; target=&quot;_blank&quot;
    
    </summary>
    
    
      <category term="响应者链" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>App Extensions篇之Sticker Pack Extension</title>
    <link href="http://yoursite.com/2017/07/11/sticker-pack/"/>
    <id>http://yoursite.com/2017/07/11/sticker-pack/</id>
    <published>2017-07-11T11:12:30.000Z</published>
    <updated>2017-07-15T14:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标明原文链接：<a href="http://supermokey.com/2017/07/11/sticker-pack/" target="_blank" rel="noopener">点击这里</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.cnblogs.com/zhanggui/p/7119572.html" target="_blank" rel="noopener">上一篇文章</a>对App Extension做了简单介绍以及对Share Extension的使用做了简单说明，本篇文章主要是对Sticker Pack Extension进行介绍。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>接下来是对Sticker Pack Extension的一些介绍。</p>
<h4 id="Sticker-Pack-Extension是什么？"><a href="#Sticker-Pack-Extension是什么？" class="headerlink" title="Sticker Pack Extension是什么？"></a>Sticker Pack Extension是什么？</h4><p>从字面看就是贴纸包扩展，更直观一点看下图：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/527522-20170711172945556-185327938.png" alt="demo"></p>
<p>iMessage里面这些都是iMesssage的Extension，但是并不是所有的Extension都是Sticker Pack Extension，有的是iMessage Extension。因此，如果是贴纸这种的Extension，才是Sticker Pack Extension。</p>
<h4 id="贴纸包如何创建呢？"><a href="#贴纸包如何创建呢？" class="headerlink" title="贴纸包如何创建呢？"></a>贴纸包如何创建呢？</h4><p>我们会看到两种情况：</p>
<p>1.没有从AppStore下载Sticker Pack，但是你可以直接在iMessage里面看到。其实这种是不是创建的Sticker Pack Extension，而是单独的Sticker pack Application。它是可以单独上线AppStore的，也就是我们经常看的这些：</p>
<p> <img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/app%20extension/messageapp.png" alt="messageapp"></p>
<p>这些椭圆形状的都是iMessage 贴纸，下载之后直接可以在iMessage里面看到。可以直接这样创建：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711174628978-142326365.png" alt="img"></p>
<p>点击所选择的那个Application之后，你会看到如下的project项目工程列表：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711174745962-1713050360.png" alt="img"></p>
<p>好吧，只有一个文件夹，后面在介绍。</p>
<p>2.没有从AppStore上面下载，但是能够在iMessage里面看到的。例如上面图示中的WWDC和知乎刘看山。它的创建方式就是App Extension。也就是我们在我们产品开发的时候，新建的一个Target:</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711174912400-803218335.png" alt="img"></p>
<p> 新建之后，你会发现项目工程目录变成这样了：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711175036259-37599785.png" alt="img"></p>
<p>上面的MessageExtensionDemo是我的工程，CustomSticker是我新建的Sticker Pack Extension。相比之下多了一个Info.plist，无非是对要展示的名称以及其他属性的设置。</p>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p> 接下来的开发让你刷新认知。因为：完全不需要编写代码！完全不需要编写代码！完全不需要编写代码！我们只要把图片放到指定的位置即可。打开Sticker.xcassets，你会发现里面是这样的：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711175502931-880133048.png" alt="img"></p>
<p>其中的iMessage App Icon就是在iMessage里面看到的icon，而Sticker Pack就是我们在iMessage里面点击icon进入的页面要展示的image.例如我自己做的这种：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/app%20extension/xiaqiu.jpg" alt="xiaqiu"></p>
<p>这里面我做的就是找一些图片，然后把这些图片放到指定的位置，把做的icon放到iMessage App Icon里面，把其他的要分享的图片放到Sticker Pack里面。然后点击运行主程序，打开iMessage app，你就会看到自己的iMessage 贴纸。</p>
<p>这里你可能注意打了展示的个数问题，有的一行四个，有的一行三个，有的一行2个。这个是因为我设置的Sticker Size：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711180514962-44324531.png" alt="img"></p>
<p>也就是说如果我用的Small，那么iMessage里面展示的就是一行四个，如果设置的Medium，那么一行展示的就是三个，如果是Large，那么一行展示的就是两个。</p>
<h4 id="Sicker-Pack-图片Size和格式"><a href="#Sicker-Pack-图片Size和格式" class="headerlink" title="Sicker Pack 图片Size和格式"></a>Sicker Pack 图片Size和格式</h4><p>官方的Sticker Size是下图左侧这样的：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711180715040-1413670628.png" alt="img"><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711181101103-251214825.png" alt="img"></p>
<p>但是我在设计图片的时候比较随意，随便设置了图片的大小，，不过看起来也还ok。</p>
<p>官方的Sticker Formats是上图右侧这样的。</p>
<p>另外，我们再看一下左下角的加号：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711181317290-1245350046.png" alt="img"></p>
<p>其中的New Sticker就是创建一个Sticker Pack，那个New Sticker Sequence很有趣，其实它就是一个图片的序列，也就是我们可以用几张连续的png图片组装成一个动态图片。这里就不举例子了，感兴趣可以自己试一下。</p>
<h4 id="关于iMessage-贴纸-icons大小"><a href="#关于iMessage-贴纸-icons大小" class="headerlink" title="关于iMessage 贴纸 icons大小"></a>关于iMessage 贴纸 icons大小</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711181720134-1351378599.png" alt="img"></h4><p>按照官网给的大小设计即可。另外如果有money，可以购买官方推荐的创建Stickers的工具：<a href="https://itunes.apple.com/us/app/motion/id434290957?mt=12&amp;v0=www-naus-motion-buynow" target="_blank" rel="noopener">Motion</a>。不过收费。。。。点击<a href="https://developer.apple.com/support/stickers/motion/" target="_blank" rel="noopener">这里</a>可查看如何使用Motion来创建Stickers。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客主要介绍了如何创建iMessage App以及如何创建贴纸扩展。比较简单。不理解的话可以留言咨询。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>1.用到的代码，点击<a href="https://github.com/ScottZg/AppExtension" target="_blank" rel="noopener">这里</a>下载（代码中的MessageExtensionDemo）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://developer.apple.com/ios/human-interface-guidelines/extensions/messaging/" target="_blank" rel="noopener">Human Interface Guidelines</a>        2<a href="https://developer.apple.com/stickers/" target="_blank" rel="noopener">.Creating Stickers for iMessage</a>      3.<a href="https://developer.apple.com/documentation/messages" target="_blank" rel="noopener">Messages</a>     4.视频：<a href="https://developer.apple.com/videos/play/tutorials/building-sticker-packs/" target="_blank" rel="noopener">Buildiing Sticker Packs</a></p>
<p>5.<a href="https://developer.apple.com/support/stickers/motion/" target="_blank" rel="noopener">Create Stickers with Motion</a></p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170711185129712-992782547.jpg" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标明原文链接：&lt;a href=&quot;http://supermokey.com/2017/07/11/sticker-pack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; 
    
    </summary>
    
    
      <category term="App Extension" scheme="http://yoursite.com/tags/App-Extension/"/>
    
      <category term="Sticker Pack" scheme="http://yoursite.com/tags/Sticker-Pack/"/>
    
  </entry>
  
  <entry>
    <title>App Extensions篇之Share Extension</title>
    <link href="http://yoursite.com/2017/07/05/app-extension/"/>
    <id>http://yoursite.com/2017/07/05/app-extension/</id>
    <published>2017-07-05T10:09:51.000Z</published>
    <updated>2017-07-15T15:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>这里主要是对App Extension的一些介绍以及详细给大家介绍一下Share Extension，后期会添加其他的Extension介绍。</p>
<h2 id="2-开始"><a href="#2-开始" class="headerlink" title="2.开始"></a>2.开始</h2><p>主要对App Extension和Share Extension进行介绍。请继续往下看：</p>
<h3 id="2-1-App-Extension的介绍"><a href="#2-1-App-Extension的介绍" class="headerlink" title="2.1: App Extension的介绍"></a>2.1: App Extension的介绍</h3><p> 官方给的说法是：App Extension可以让你扩展你的APP的自定义功能和内容，使用户可以在与其他应用或者系统进行互动的时候去使用它。翻译的不一定准确，这样说可能会好理解：我们平时看到的Widget、微信和QQ的share等等，都是App Extension，下图是一些例子：</p>
<p><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/app%20extension/extentiondemo.png" alt="demo"></p>
<p>其实就是我们经常看到的Widget，但是Widget只是Today Extension，除了Today Extension，还有很多。</p>
<p>一个支持扩展的系统区域叫做一个extension point(扩展点)。每个扩展点的扩展都有自己独有的使用方法和API。你可以根据你的需求来选择不同的扩展。官方API里面提出了一个名词叫：Host app，我们可以把它理解为宿主的App也就是提供应用扩展界面显示或者功能的App。还有一个container app，我们可以把它理解为容器App，就像上图的微信share extension，容器app就是微信。</p>
<p>扩展和app不同，扩展无法单独上架AppStore。尽管你必须使用个app来包含并且分发你的extension，extension也是一个单独的二进制文件，独立于用于传递和分发的container app。</p>
<p>你可以通过File—&gt;New —&gt;Target来创建Extension，它和其他的target一样，它和你的app project组合成为一个产品。一个app可以有一个扩展，也可以有多个扩展。最好的创建扩展的方式就是通过Xcode提供的Extension种类选择自己需要的来创建，里面包含了必要的API以及方法实现。</p>
<p>如果你想让用户去使用你的扩展，那么就需要吧你的containing app发布到AppStore，当用户安装了你的Containing app，扩展也就安装了。不同的扩展启动的方式也不一样，例如Today Extension，你需要Widget来展示到你的通知中心。扩展也不要乱用，扩展的最佳用户体验从来都是希望用户操作更精简、更快速，并且专注于单个任务。</p>
<h4 id="2-1-1-Extension的种类"><a href="#2-1-1-Extension的种类" class="headerlink" title="2.1.1: Extension的种类"></a>2.1.1: Extension的种类</h4><p>我们可以在Xcode的File—&gt;New—&gt;Target里面看到不同平台的Extension，包括iOS、watchOS、tvOS、macOS等等。这里主要介绍iOS，主要包括以下几种Extensions：</p>
<p>1.Action Extension：动作扩展，在另一个应用程序的上下文中操作或者查看内容</p>
<p>2.Audio Unit Extension：音频单元扩展</p>
<p>3.Broadcast UI Extension：广播UI 扩展</p>
<p>4.Broadcast Upload Extension：广播上传扩展</p>
<p>5.Call Directory Extension：呼叫目录扩展</p>
<p>6.Content Blocker Extension：内容拦截器扩展</p>
<p>7.Custom Keyboard Extension：键盘扩展，例如第三方的键盘，搜狗输入法，百度输入法等。</p>
<p>8.iMessage Extension：消息的扩展</p>
<p>9.Intents Extension：Intents扩展</p>
<p>10.Intents UI Extension：Intents UI扩展</p>
<p>11.Notification Content Extension：通知内容扩展</p>
<p>12.Notification Service Extension：通知服务扩展</p>
<p>13.Photo Editing Extension：图片编辑扩展，在照片app中编辑照片或者视频</p>
<p>14.Share Extension：分享扩展，发布一个共享网站或者与其他应用共享内容。</p>
<p>15.Shared Links Extension：分享链接扩展</p>
<p>16.Spotlight Index Extension：Spotlight 索引扩展</p>
<p>17.Sticker Pack Extension：贴纸包扩展</p>
<p>18.Today Extension：Today扩展，可以快速获取更新或者在通知中心的近日视图中执行一项快速任务。</p>
<p>等等。也可直接在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/" target="_blank" rel="noopener">这里</a>参见更多extension。</p>
<h4 id="2-1-2-App-Extensions的生命周期"><a href="#2-1-2-App-Extensions的生命周期" class="headerlink" title="2.1.2: App Extensions的生命周期"></a>2.1.2: App Extensions的生命周期</h4><p>先上图，估计你已经看到了好多次这张图，恭喜你这次又看到了，因为这个是苹果官方提供的图片。</p>
<p> <img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705102535331-1899066550.png" alt="img"></p>
<p>1.用户选择要使用的App extension</p>
<p>2.系统启动App Extension</p>
<p>3.App Extension 代码运行</p>
<p>4.运行完之后系统kill掉App Extension</p>
<p>这就是App Extension的生命周期，举个例子：</p>
<p>一个Share Extension，在图库里面你选择了一张图片，然后点击分享，选择你的Share Extension(第一步)，此时系统会启动你的Share Extension（第二步）。然后你将选择的图片分享到指定的程序（例如微信的发送给朋友）（第三步）。接下来分享页面关闭，系统kill掉了Share Extension。</p>
<h4 id="2-1-3-App-Extension的通信方式"><a href="#2-1-3-App-Extension的通信方式" class="headerlink" title="2.1.3: App Extension的通信方式"></a>2.1.3: App Extension的通信方式</h4><p>App Extension主要的通信是和他的host app（例如微信的Share Extension和微信），来自host app的请求和extension的response。下图你应该也很熟悉（app 扩展直接和host app沟通）：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705104333847-1846615158.png" alt="img"></p>
<p>这个展示的就是正在运行的App Extension、host app和containing app之间的关系。可以看出：Containing App和app Extension并没有直接的沟通。甚至有的时候Containing app可以不运行，而App Extension直接运行。Containing app和Host app没有任何的沟通。</p>
<p>在一个典型的request/response中，系统打开代表host app(图库)的extension（微信分享的share extension），把host app提供的数据(图片和选择的好友)输送到extension的context，然后extension展示界面，提供一些功能任务（例如微信的分享到朋友）。</p>
<p>还有一种是app extension可以直接和他的containing app沟通：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705105654128-858528359.png" alt="img"></p>
<p>例如Today Widget，可以直接告诉系统打开他的Containing app，只需要调用NSExtensionContext的openURL:CompletionHandler:方法即可。</p>
<h4 id="2-1-4-在App-Extension中不可以做的事情"><a href="#2-1-4-在App-Extension中不可以做的事情" class="headerlink" title="2.1.4: 在App Extension中不可以做的事情"></a>2.1.4: 在App Extension中不可以做的事情</h4><p>一个app extension不能有以下情况：</p>
<p>1.访问sharedApplication对象。因此不能使用任何该对象的防范</p>
<p>2.使用任何标记NS_EXTENSION_UNAVAILABLE宏的API，或者类似的宏，或者不可用framework里面的API，例如HealthKit framework不能用于app extensions</p>
<p>3.iOS设备访问相机或者麦克风（iMessage app可以访问这些资源，只要在Info.plist里面进行配置使用描述即可）</p>
<p>4.运行一个长时间的后台任务（根据不同平台而异）</p>
<p>5.使用AirDrop接收数据</p>
<h3 id="2-2-Share-Extension的简单使用"><a href="#2-2-Share-Extension的简单使用" class="headerlink" title="2.2: Share Extension的简单使用"></a>2.2: Share Extension的简单使用</h3><p>这里我们以Share Extension为例进行介绍。</p>
<h4 id="2-2-1-选择正确的Extension-Point开始开发"><a href="#2-2-1-选择正确的Extension-Point开始开发" class="headerlink" title="2.2.1: 选择正确的Extension Point开始开发"></a>2.2.1: 选择正确的Extension Point开始开发</h4><p>当你创建app extension的时候，可以直接使用Xcode自带的模板创建你需要的Extension。点击File—&gt;New—&gt;Target:</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705134945519-1038614069.png" alt="img"></p>
<p>从这里选择符合你需求的Extension，当你创建完毕后，你的项目工程目录就会多一个文件夹：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705135349378-208763937.png" alt="img"></p>
<p>可以发现多了一个.swift、.storyboard和一个Info.plist。接下来你也会在Scheme里发现一个Extension，而且多了一个以.appex为后缀的Bundle</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705135725269-445755128.png" alt="img"></p>
<p>这里需要注意：</p>
<p>一个app extension必须在architectures build settings 里面包含arm64(ios)或者x86_64(OS X)，否则containing app上架的时候将会被拒绝。Xcode默认的Standard architecture包含了64-bit的architecture。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">An app extension target must include the arm64 (iOS) or x86_64 architecture (OS X) in its Architectures build settings or it will be rejected by the App Store. Xcode includes the appropriate 64-bit architecture with its “Standard architectures” setting when you create a new app extension target.</div><div class="line"></div><div class="line">If your containing app target links to an embedded framework, the app must also include 64-bit architecture or it will be rejected by the App Store.</div></pre></td></tr></table></figure>
<h4 id="2-2-2-来看看默认的App-Extension模板"><a href="#2-2-2-来看看默认的App-Extension模板" class="headerlink" title="2.2.2: 来看看默认的App Extension模板"></a>2.2.2: 来看看默认的App Extension模板</h4><p>从上面的项目工程目录看，每个extension都包含了一个plist文件、一个视图控制器类和一个默认的user interface，这些都是被extension point定义的。我们先来看一下Info.plist里面的东西：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705140522737-1747206257.png" alt="img"></p>
<p>再看看项目工程的Info.plist：<br><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705140639440-1368881952.png" alt="img"></p>
<p>两者可以进行一个对比，可以看出：</p>
<p>1、<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html" target="_blank" rel="noopener">CFBundlePackageType</a>不一样，项目是APPL，而Extension的是XPC！</p>
<p>2、比较明显的就是App Extension里面多了一个NSExtension的字典。 </p>
<p>在Info.plist中，该文件必须包含NSExtension键和扩展点指定的键和值的字典。这里的ExtensionPointIdentifier是com.apple.share-services，因为我创建的是Share Extension。</p>
<p>这里注意，如果你的app extension的Info.plist里面包含了UIBackgroundModes key那么将无法通过AppStore的审核。 </p>
<h4 id="2-2-3：调试App-Extension"><a href="#2-2-3：调试App-Extension" class="headerlink" title="2.2.3：调试App Extension"></a>2.2.3：调试App Extension</h4><p>调试App Extension很简单，你要做的就是选择（scheme）扩展，然后点击Run， 就会弹出一个弹框让你选择Host app，选择Host app之后便可以运行调试。比如你调试Share Extension，你可以选择照片，然后让照片当Host app，然后运行之后就会打开照片，选择分享就会看到你的app扩展，然后进行debug断点处理等。</p>
<h3 id="2-3：Share-Extension-Demo"><a href="#2-3：Share-Extension-Demo" class="headerlink" title="2.3：Share Extension Demo"></a>2.3：Share Extension Demo</h3><p>先看一下我自己做的分享Demo效果：<br><img src="https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/app%20extension/selfdemo.jpg" alt="mysharedemo"></p>
<p>然后在containing app里面查看分享的图片：如上图的第三张图。先看一下这里默认创建的Share Extension的视图控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class ShareViewController: SLComposeServiceViewController &#123;</div><div class="line"></div><div class="line">    override func isContentValid() -&gt; Bool &#123;</div><div class="line">        // Do validation of contentText and/or NSExtensionContext attachments here</div><div class="line">        return true</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override func didSelectPost() &#123;</div><div class="line">        // This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments.</div><div class="line">    </div><div class="line">        // Inform the host that we&apos;re done, so it un-blocks its UI. Note: Alternatively you could call super&apos;s -didSelectPost, which will similarly complete the extension context.</div><div class="line">        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override func configurationItems() -&gt; [Any]! &#123;</div><div class="line">        // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here.</div><div class="line">        return []</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面主要有三个方法：</p>
<p>isContentValid是用来判断内容是否可用的,这里可以做一些校验，比如我们分享的内容是否符合要分享的要求，如果返回false，那么在上图的Post按钮就无法点击了。因为一旦返回false，则说明分享内容不符合要求，也就无法Post了。</p>
<p>configuration是一个配置数组，它可以配置多个列表，例如微信分享的[发送给朋友，分享到朋友圈，收藏]：</p>
<p> <img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705152235081-1853942554.jpg" alt="img"></p>
<p> didSelectPost是你点击发送之后处理的事件，比如微信的点击收藏，可以调用微信的api，然后进行收藏。默认的注释也说明了本方法的作用：</p>
<p>当用户选中post之后调用。是对内容或者NSExtensionContext附件的上传。我这里使用App Group的方式进行app Extension和containing app进行交互。先将内容存储到UserDefaults，然后再在containing app里面取出图片展示到containing app里面。</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705152736769-1623236094.png" alt="img"></p>
<p>这里我把图片存储到了UserDefaults，然后在Containing app里面获取：</p>
<p><img src="http://images2015.cnblogs.com/blog/527522/201707/527522-20170705152904894-162392710.png" alt="img"></p>
<p> suite的name是app group的名称。具体可参见<a href="https://github.com/ScottZg/AppExtension" target="_blank" rel="noopener">Github源码</a>里的ShareExtension。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>App Extension的出现使App的使用更加方便，比如系统的天气widget，还有类似微信（QQ）的分享，完全可以实现不打开containing app而直接使用share extension分享。</p>
<p> 在后续的时间里，将会不定期进行更新，给读者介绍其他的Extension，如有任何疑问，随时留言沟通。</p>
<p>参考资料</p>
<p>1、<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/" target="_blank" rel="noopener">App Extension Programming Guide </a></p>
<p>2、<a href="http://www.infoq.com/cn/news/2014/07/apple-ios8-app-extensions" target="_blank" rel="noopener">深入App Extensions for iOS8</a></p>
<p>3、<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html" target="_blank" rel="noopener">Information property List Key Reference</a></p>
<p>4、<a href="https://developer.apple.com/library/content/documentation/Gen" target="_blank" rel="noopener">App Extension Programming Guide—Share</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;这里主要是对App Extension的一些介绍以及详细给大家介绍一下Share Extension，后期会添加其他的Ext
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Apple本地认证(密码+Touch id)</title>
    <link href="http://yoursite.com/2017/05/11/local-auth-touch-id/"/>
    <id>http://yoursite.com/2017/05/11/local-auth-touch-id/</id>
    <published>2017-05-11T05:26:29.000Z</published>
    <updated>2017-05-11T05:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>本片博客主要介绍如何在自己的APP中添加指纹解锁/密码解锁技术。主要是对苹果的LocalAuthentication的介绍。看过之后你将会知道如何使用苹果的指纹解锁和本地密码验证功能。</p>
<h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>Apple有好多Frameworks，包括常用的UIKit、Foundation和Accounts等等。其中还有一个Framework：LocalAuthentication。该Framework名如其功能，提供额本地认证的功能：也就是我们平时说的密码验证和指纹解锁功能。该Framework的内容如下：<br><img src="https://ooo.0o0.ooo/2017/05/10/5912dad5ba754.png" alt="LocalAuthentication"><br>它包含了三个类</p>
<blockquote>
<p>LAContext.h<br>LAError.h<br>LAPublicDefines.h<br>LocalAuthentication.h(包含文件，即里面包含了该Framework里面的其他类头文件)</p>
</blockquote>
<p>LAPublicDefines.h该类是本地验证的定义类，里面定义了五类String：Pocicies/Options/Credential types/Error codes/Error domain。<br>   Policies:</p>
<blockquote>
<p>LAPolicyDeviceOwnerAuthenticationWithBiometrics:使用Touch id来验证设备所有者<br>LAPolicyDeviceOwnerAuthentication：使用Touch id或者设备密码来验证用户</p>
</blockquote>
<p>   Options：</p>
<blockquote>
<p>kLAOptionUserFallback<br>kLAOptionAuthenticationReason</p>
</blockquote>
<p>   ​Credential types:</p>
<blockquote>
<p>kLACredentialTypePasscode<br>kLACredentialTypePassphrase<br>kLACredentialCTKPIN</p>
</blockquote>
<p>   ​Error codes:</p>
<blockquote>
<p>kLAErrorAuthenticationFailed:认证失败<br>kLAErrorUserCancel:用户取消<br>kLAErrorUserFallback<br>kLAErrorSystemCancel:系统取消<br>kLAErrorPasscodeNotSet:没有设置密码<br>kLAErrorTouchIDNotAvailable: Touch id不可用<br>kLAErrorTouchIDNotEnrolled<br>kLAErrorTouchIDLockout<br>kLAErrorAppCancel: app 取消<br>kLAErrorInvalidContext</p>
</blockquote>
<p>   ​Error domain:</p>
<blockquote>
<p>kLAErrorDomain:</p>
</blockquote>
<p>LAContext.h该类中有个LAPolicy的枚举：LAPolicyDeviceOwnerAuthenticationWithBiometrics(使用 touch id 认证)和LAPolicyDeviceOwnerAuthentication(使用密码或者设备密码进行验证设备所有者)。</p>
<p>需要注意，对于LAPolicyDeviceOwnerAuthenticationWithBiometrics，Touch ID认证的时候我们的设备必须有Touch ID设置，如果没有或者该设备本身不支持Touch ID，前者认证就会失败，如果Touch ID被锁定，则需要输入密码来解锁Touch ID。另外，Touch ID如果输入错误5次将会被锁定，此时用户必须使用输入密码的方式来结果它。如果密码输入也错误的话，你在设置—&gt;Touch ID里面就会看到：</p>
<p>   <img src="https://ooo.0o0.ooo/2017/05/10/5912e4103b9ae.png" alt="密码错误"><br>   并且只有经过一段时间之后才能使用。<br>   对于后者的LAPolicyDeviceOwnerAuthentication，它的意思是Touch ID或者密码来解锁。意思就是如果Touch ID可用，并且没有锁定，用户第一次会要求使用指纹解锁，否则就会使用密码解锁。这里和另一个枚举不一样的是：<br>   对于LAPolicyDeviceOwnerAuthenticationWithBiometrics：<br>   <img src="https://ooo.0o0.ooo/2017/05/10/5912e59fc50b5.png" alt="第一次提示"></p>
<p>   <img src="https://ooo.0o0.ooo/2017/05/10/5912e5a002b5f.png" alt="第一次输入错误提示"><br>   对于LAPolicyDeviceOwnerAuthentication：<br>   除了前面的两个提示外，还有<br>   <img src="https://ooo.0o0.ooo/2017/05/10/5912e67f77644.png" alt="指纹一直错误弹出密码输入"><br>   直接上代码，看看如何实现指纹解锁或者指纹+密码解锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (IBAction)authAction:(id)sender &#123;</div><div class="line">    LAContext *myContext = [[LAContext alloc] init];</div><div class="line">    NSError *myError = nil;</div><div class="line">    if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&amp;myError]) &#123;</div><div class="line">        [myContext evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@&quot;通过Home键验证已有手机指纹&quot; reply:^(BOOL success, NSError * _Nullable error) &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                NSLog(@&quot;认证成功&quot;);</div><div class="line">            &#125;else &#123;</div><div class="line">                NSLog(@&quot;认证失败,%@&quot;,[error description]);</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;error %@&quot;,[myError description]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先是实例化一个LAContext的上下文，然后首先有个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError * __autoreleasing *)error __attribute__((swift_error(none)));</div></pre></td></tr></table></figure></p>
<p>验证一下我们制定的LAPolicy是否可以使用，error用来记录不可使用的原因。<br>接下来就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)evaluatePolicy:(LAPolicy)policy</div><div class="line">       localizedReason:(NSString *)localizedReason</div><div class="line">                 reply:(void(^)(BOOL success, NSError * __nullable error))reply;</div></pre></td></tr></table></figure></p>
<p>其中的policy就是我们刚才验证的policy，然后localizedReason是我们使用验证的原因，也就是上面途中显示的“通过Home键验证已有手机指纹”。最后通过block回调判断结果，succes查看是否成功，error查看如果失败的话，失败的原因。<br>到这里，你已经知道了如何使用指纹解锁，为你的app添加指纹解锁功能。</p>
<p>后续LAContext里面其他的method或者property有了解了再补充。</p>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><ul>
<li>Apple官方文档：<a href="https://developer.apple.com/reference/localauthentication" target="_blank" rel="noopener">https://developer.apple.com/reference/localauthentication</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;本片博客主要介绍如何在自己的APP中添加指纹解锁/密码解锁技术。主要是对苹果的LocalAuthentication的介绍。看过之后你将会知
    
    </summary>
    
    
      <category term="Touch ID" scheme="http://yoursite.com/tags/Touch-ID/"/>
    
  </entry>
  
  <entry>
    <title>记录参加QCon的心得</title>
    <link href="http://yoursite.com/2017/04/20/qcon-recorder/"/>
    <id>http://yoursite.com/2017/04/20/qcon-recorder/</id>
    <published>2017-04-20T08:28:21.000Z</published>
    <updated>2017-04-20T08:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="记录参加QCon的心得"><a href="#记录参加QCon的心得" class="headerlink" title="记录参加QCon的心得"></a>记录参加QCon的心得</h4><p><img src="https://ooo.0o0.ooo/2017/04/20/58f865073be25.jpg" alt="QCon"><br>很荣幸参加QCon全球软件开发大会，这里特别感谢我们部门的总经理，也是《互联网广告算法和系统实践》此书的作者王勇睿。因为他我才有这次参会机会参加这次软件开发大会。<br>接下来，我将从以下几点来撰写这篇文章：</p>
<ol>
<li>什么是QCon？</li>
<li>我参加的专题演讲有哪些？</li>
<li>我在QCon大会上学习到了什么？</li>
</ol>
<h5 id="1-什么是QCon？"><a href="#1-什么是QCon？" class="headerlink" title="1.什么是QCon？"></a>1.什么是QCon？</h5><p>QCon是由InfoQ主办的全球顶级技术盛会，每年在伦敦、北京、东京、纽约、圣保罗、上海、旧金山召开。自2017年3月份首次举办以来，已有超过万名高级技术人员参加过QCon大会。QCon内容源于实践并面向社区，演讲嘉宾依据热点话题，面向5年以上工作经验的技术团队负责人、架构师、工程总监、高级开发人员分享技术创新和最佳实践。<br>北京QCon2017是在国家会议中心举办，时间为：2017年4月16日—18日。</p>
<h5 id="2-我参加的专题研究有哪些？"><a href="#2-我参加的专题研究有哪些？" class="headerlink" title="2.我参加的专题研究有哪些？"></a>2.我参加的专题研究有哪些？</h5><p>由于时间原因，我是最后一天去的QCon。早上8：30起床，然后坐地铁到了国家会议中心。然后开始了参会学习。以下是参会内容：</p>
<h6 id="Part-1-《Software-Performance-Analytics-Past-Present-and-Future》"><a href="#Part-1-《Software-Performance-Analytics-Past-Present-and-Future》" class="headerlink" title="Part 1.《Software Performance Analytics: Past,Present and Future》"></a>Part 1.《Software Performance Analytics: Past,Present and Future》</h6><p>演讲人是Kingsum，来自阿里，是阿里巴巴基建服务首席专家。主要介绍的是软件性能分析：过去，现在和未来。<br>可能是自己英文差的原因，他演讲的过程中经常出现各种英文，所以有的时候没有听太懂。(学习英文很重要)<br>他介绍了一个好的程序，但是有一下几点会影响或者制约其功能：</p>
<ul>
<li>Software doesn’t scale</li>
<li>Hardware is too slow</li>
<li>Tuning software doesn’t work</li>
<li>Tuning software in the data center is difficult<br>这个Part就这么多了，讲的太高深，表示没有听懂。</li>
</ul>
<h6 id="Part-2-《代码未写，漏洞已出–谈谈设计不当导致的安全问题》"><a href="#Part-2-《代码未写，漏洞已出–谈谈设计不当导致的安全问题》" class="headerlink" title="Part 2.《代码未写，漏洞已出–谈谈设计不当导致的安全问题》"></a>Part 2.《代码未写，漏洞已出–谈谈设计不当导致的安全问题》</h6><p>演讲人是于旸（TK老师），他是腾讯玄武实验室总监。主要介绍了：</p>
<ul>
<li>设计不当导致的漏洞。<br>设计分为单点设计和多点耦合。举个例子来说，单点设计就是只设计一个功能，多点耦合就是多个功能组合在一起去实现某个新的功能。也许一个功能的设计是没问题的，也不会出现错误，但是如果多个没有问题的功能组合成一个新的功能，由于耦合也许就会出现漏洞。<br>就拿类似购物类的系统，支付系统和交易系统本身他们是没有任何漏洞可言的。但是当我们将他们组合使用的时候就容易产生问题。比如我们在交易的时候手动将交易金额改写，100元改成1元，支付系统不会校验钱数，只会告诉用户是否支付成功，所以当交易的时候，交易系统收到了支付系统返回的成功就会提示用户购买商品成功。这样的话你就用1元买了100元的商品。比较靠谱的办法就是在支付系统成功之后返回给交易系统成功再加上支付金额。这样就能避免这个漏洞了。</li>
<li>实现不当导致的漏洞。<br>举个例子，对比两个字符串相等的方法，在对比对应位的字符是否相等时，我们也许这样来判断：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> bool <span class="title">isEqual</span><span class="params">(String s1,String s2)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (s1.length != s2.length) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length;i++) &#123;</div><div class="line">		<span class="keyword">if</span> (s1[i] != s2[i]) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里在对比s1[i]与s2[i]不相等的时候（类代码，也许不能运行），攻击者可能会在for循环做事情，比如黑客通过某种攻击让代码返回true，那么就算是两个不相等的字符串也会返回true，但是这里面有一点我们会忽略，那就是时间维度。一般来说，如果对比两个字符串最慢只需要1s，但是被黑客攻击的代码由于需要进行破解攻击，所以消耗的时间也会长一点，所以如果我们的代码在实现的过程中考虑到时间，那么代码就会更健壮，不容易攻破。<br>TK老师也说明了这一点：时间是很容易被忽略的维度。</p>
<ul>
<li>使用不当导致的漏洞。<br>这里TK老师还介绍了他们用扫描器做实验，扫描的的初衷就是让支付和读取数据方便，但是它有的时候可以做为一个外接键盘。将控制电脑的指令装载在二维码或者条形码里面，然后通过扫码器就能够控制电脑。甚至也可以利用激光灯，通过激光灯远程照射让扫描器识别，进而控制电脑。<br>另外还有运营商的“短信保管箱”、”自助换卡”等功能，由于涉及不当也在推出一段之间之后被取消。这里的短信保管箱就是运营商将短信同步到云里面，然后就算用户手机不再身边也可以通过登录云查看短信。但是业界公认手机验证码作为安全验证，如果用户的短信存储云密码被盗，那么用户的短信安全验证也就失去了作用。<br>期间还说了一些漏洞问题，比如badbarcode问题、badtunnel问题等等。<br>一句话总结：是故圣人不治已病治未病，不治已乱治未乱。</li>
</ul>
<h6 id="Part3-《软件开发之禅》"><a href="#Part3-《软件开发之禅》" class="headerlink" title="Part3.《软件开发之禅》"></a>Part3.《软件开发之禅》</h6><p>演讲人是蔡超，Amzaon(中国)技术团队的首席架构师。主要介绍了以下几点：</p>
<ul>
<li>形似与神似<br>这里主要讲了MVC。其实还有很多其他的架构：MVVM、MVP等等，其实他们的本质都是MVC的衍生。我们要在使用的过程中发现其本质的东西，也要发现其差异。</li>
<li>教条与变通<br>这里我听到最多的是黑板模式，所谓黑板模式，就是应用中的多种不同数据处理逻辑相互影响和协同完成数据分析处理，就好像多位不同的专家在同一黑板上交流思想，每个转件都可以获得别的专家写在黑板上的信息，同时也可以用自己的分析去更新黑板上的信息，从而影响其他专家。比较典型的使用就是数据库：数据库充当黑板，不同的应用共享数据库中的信息，并且可以更新数据信息。是最常见的实现方式。</li>
<li>优势与劣势<br>一个新的技术出现之后，它可能会给大家带来方便，进而去解决那些现在已知技术无法解决的问题。但是我们一定要明白：使用新技术的同时一定要考虑到新技术所带来的问题。只有将其研究之后，然后将其所带来的其他问题解决，这样才可以尝试去使用，以免在以后的过程中遇到问题再去想解决方法。要平衡使用中的矛盾。</li>
<li>数据与模型</li>
<li>简单与容易</li>
</ul>
<p>我们遇到问题的时候，想到的不是用如何牛逼的方法去解决，而是从问题的本身去开始研究，从最简单的技术开始，一定要找到最简单、最有效、最实用的方法去解决。<br>在我们学习或者读书的时候，我们应该在学习的时候先问一下自己：我学的东西要解决的问题是什么？ 当我们学习完之后，要想想学过之后是否解决了我们遇到的问题。<br>总之这场分享听下来之后，给我的感觉就是一定要发现事物的本质，用最简单、最有效、最实用的方法去解决问题，而不是多绕弯路。</p>
<h6 id="Part4-《基于移动的快速工程模式》"><a href="#Part4-《基于移动的快速工程模式》" class="headerlink" title="Part4.《基于移动的快速工程模式》"></a>Part4.《基于移动的快速工程模式》</h6><p>演讲人是徐大芮（子之），淘宝无线技术专家。内容主要是如何基于移动，应用去做快速开发。<br>主要是为了应对手淘的快速开发，比如马老板说淘宝首页来个发红包，那么就需要及时迅速的去完成这个需求。而他们开发团队仅仅用了几个小时就将此需求上线。<br>在应对业务发展快、流量集中、交互复杂的情况下（过山车），如何快速开发完成并成功上线是一个很值得研究的问题。<br>所以他们就通过模板配置、插件组装的方式来让研发提速。比如说淘宝的一个页面：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f858a60a787.png" alt="模板化"><br>他们做了一套模板，然后去承载这个页面，然后通过配置数据，从而完成了快速开发迭代。在开发的过程中如果可以使用现有模板，那么久直接装载即可。在开发过程中，模板会有不同的版本，有自己的独立版本控制，而业务实例每个版本都有独立关联的一个模板ID和版本。<br>然后还开发了各种组件，榜单、投票、评论等等，通过数据配置就能完成快速开发。<br>另外还有淘宝不定期推出的活动动画，淘宝这边使用AE做成动画，然后用JSON承载，然后通过移动端的ViewController上面的一层Layer或者Player来展示，期间允许对JSON进行二次定制开发。<br>这里还有一个很有趣的事情，有位观众提了一个问题：苹果不允许JSBridge，那马如何实现不发版的情况下实现更新呢？演讲人的回答是不知道。但是他说不太确定苹果是不允许拉文件更新，还是允许类似RN方式的开发。如果只是不允许拉文件的话，那么可以考虑使用RN的方式来搞。</p>
<h6 id="Part5-《3x3-提速移动App交付》"><a href="#Part5-《3x3-提速移动App交付》" class="headerlink" title="Part5.《3x3:提速移动App交付》"></a>Part5.《3x3:提速移动App交付》</h6><p><img src="https://ooo.0o0.ooo/2017/04/20/58f85e0d5330d.png" alt="3x3提速开发交付"><br>演讲人是来自LinkedIn的软件开发工程师胡克秋。主要介绍了如何快速发版。<br>介绍了LinkedIn发版，说是一周发一次，我看了一下领英iOS更新记录，没有那么频繁，也许是能够支持一周发一次吧。<br>他们移动开发是专门的一个移动平台组，里面没有任何的产品、UI什么的。当其他有需求的时候，就会把人派到指定的部门开发。从当初的30个移动工程师到现在的超过300个移动工程师，从原来的的超过一个月交付一次App到现在的3x3快速开发。<br>所谓3x3快速开发，就是：<br>一天发布3次。<br>代码提交到发布&lt;3个小时<br>后来经了解他们的1天发布三次其实是每天发布3个可用的版本，这些版本能够随时拿过来使用。<br>他们的iOS客户端完全采用Swift开发。因此在经历Swift2.2—Swift3.0升级的过程中，8个人在开发项目室从上午9：00到晚上10：00做升级。总共用了一个礼拜的时间才将Swift2.2升级到了Swift3.0。<br>关于代码提交，他们只有一个分支，然后在开发过程中，他们有个小要求：就是在有限制的时间内做代码提交，如果超过了这个deadline，那么久不能提交代码。这样保证了代码在某个时间点的稳定性。<br>关于测试，他们还有个DogFood，也就是所有公司员工必须去使用他们的最新版本，然后他们会收集Crash信息，然后进行修复。<br>还顺便介绍了几个开源的框架：</p>
<ol>
<li><a href="https://github.com/linkedin/LayoutTest-iOS" target="_blank" rel="noopener">LayoutTest-iOS</a></li>
<li><a href="https://github.com/linkedin/bluepill" target="_blank" rel="noopener">bluepill</a><br>有兴趣的同学可以自行下载查看。<br>还有一点：他们的iOS开发做UITest和UnitTest，关于测试，他们做的很足，而且一般QA写测试场景，开发写测试用例。而且他门能够很好控制写测试用例的时间再10%左右。<br>以上就是我在QCon上参加的专题演讲。</li>
</ol>
<h5 id="3-我在QCon大会上学习到了什么？"><a href="#3-我在QCon大会上学习到了什么？" class="headerlink" title="3. 我在QCon大会上学习到了什么？"></a>3. 我在QCon大会上学习到了什么？</h5><p>以下是对我学到的东西进行的一些简单总结：</p>
<ol>
<li>编程不仅仅只是写代码那么简单，还有多考虑其安全性。另外在设计的时候也要提前构思、考虑全面</li>
<li>用最有效最实用、最简单的方法去解决问题。</li>
<li>新技术的产生有的时候一定要先对其进行学习和多方面的了解。如何应对新技术可能引发的问题？如果解决？</li>
<li>人家的iOS开发都是有用UITest和UnitTest。</li>
<li>通过模块和组件化的方式做开发，提升开发效率。</li>
<li>学习好英语很重要。</li>
<li>使用模块化和组件化的方式提高开发效率。（个人觉得仅限于比较大型的项目，小项目就大材小用了）</li>
</ol>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>如有侵权，请告知作者删除。scottzg@126.com</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;记录参加QCon的心得&quot;&gt;&lt;a href=&quot;#记录参加QCon的心得&quot; class=&quot;headerlink&quot; title=&quot;记录参加QCon的心得&quot;&gt;&lt;/a&gt;记录参加QCon的心得&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017
    
    </summary>
    
      <category term="心得" scheme="http://yoursite.com/categories/%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="QCon" scheme="http://yoursite.com/tags/QCon/"/>
    
      <category term="LinkedIn" scheme="http://yoursite.com/tags/LinkedIn/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
</feed>
